<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu Server 18.04 LTS 使用Shadowsocks-ShadowsocksR访问互联网]]></title>
    <url>%2F2018%2F08%2F23%2FUbuntu%20Server%2018.04%20LTS%20%E4%BD%BF%E7%94%A8Shadowsocks-ShadowsocksR%E8%AE%BF%E9%97%AE%E4%BA%92%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[说在前面由于一时兴起，搞了一台服务器主机，然后想试试在这台服务器主机上编译一下 LineageOS 15.1 看看效果。所以在弄好其他的东西之后开始拉源码，首先是编译工具的安装，这个基本上没问题，但是在拉源码的时候出了问题，要么是速度只有 20k ，要么就是直接出问题，清华源实在是…………emmmmmmmm…………在经过两天的尝试之后，算是摸出了一个办法可以使得拉源码的速度达到带宽的满速（我的带宽是 20m ），故此记录。 配置列表 服务器主机系统：Ubuntu 18.04.1 LTS x86_64 一个SS/SSR节点（如果没有的可以通过我的推广链接购买一个） 对于翻墙服务的可靠性不做保证 对于翻墙服务的可靠性不做保证！ 对于翻墙服务的可靠性不做保证！ 这个机场是在TG群里随手收藏的一个，今天是我第一次购买，也是想试一下是不是因为我的自建节点有问题所以导致速度慢。 开始安装Shadowsocks/ShadowsocksR根据你的节点是 SS 还是 SSR 选择安装 Shadowsocks安装由于是 server ，所以在这里我只介绍命令行的安装。 shadowsocks 运行的时候通过 python ，所以需要先安装 python1sudo apt-get install python 接着安装 python 的包管理器 pip1sudo apt-get install python-pip 之后我们通过 pip 直接安装 shadowsocks1sudo pip install shadowsocks 配置Shadowsocks在任意地方新建一个配置文件shadowsocks.json（在这里我放在/etc/shadowsocks/shadowsocks.json中），然后配置相关参数12345678&#123; "server": "&#123;your-server&#125;", "server_port": 12345, "local_port": 1080, "password": "&#123;your-password&#125;", "timeout": 600, "method": "aes-256-cfb"&#125; 注意替换配置中的相关节点信息注意替换配置中的相关节点信息注意替换配置中的相关节点信息 启动shadowsocks服务1sudo sslocal -c /etc/shadowsocks/shadowsocks.json -d start 至此， Shadowsocks 的安装和配置完成 ShadowsocksR安装在此我们不讨论SSR和SS的爱恨情仇，你想用哪个就用哪个，喜欢哪个就用哪个在客户端安装 SSR 按理说也很简单，但是我当初找了很久才找到一个脚本，其他的基本上都是服务端的安装。 安装git这个 SSR 脚本会使用git自动将SSR下载到本地，所以在这里我们先安装git1sudo apt-get install git 安装ShadowsocksR或者 SSR 脚本1wget https://github.com/the0demiurge/CharlesScripts/raw/master/charles/bin/ssr 这个脚本算是写的比较完善了，里面封装了 SSR 的安装、配置、启动、关闭等功能。为了方便操作，我们将脚本放进/usr/local/bin中12sudo mv ssr /usr/local/binsudo chmod 766 /usr/local/bin/ssr 接下来我们通过脚本安装SSR1ssr install 配置ShadowsocksR第一次安装完成之后回自动打开配置文件，如下所示：12345678910111213141516171819202122232425&#123; "server": "&#123;your-server&#125;", "server_ipv6": "::", "server_port": 12345, "local_address": "127.0.0.1", "local_port": 1080, "password": "&#123;your-password&#125;", "method": "aes-256-cfb", "protocol": "origin", "protocol_param": "", "obfs": "plain", "obfs_param": "", "speed_limit_per_con": 0, "speed_limit_per_user": 0, "additional_ports" : &#123;&#125;, // only works under multi-user mode "additional_ports_only" : false, // only works under multi-user mode "timeout": 120, "udp_timeout": 60, "dns_ipv6": false, "connect_verbose_info": 0, "redirect": "", "fast_open": false&#125; 注意替换配置中的相关节点信息注意替换配置中的相关节点信息注意替换配置中的相关节点信息配置好之后会自动启动SSR，如果输出的日志没有提示错误的话，那么 ShadowsocksR 的配置就完成了。 将SOCKS代理转换为HTTP代理我尝试过privoxy和polipo，最终发现privoxy好一些。 安装配置privoxy如果你想使用polipo，请跳过本节。12sudo apt-get install privoxy #安装privoxysudo vim /etc/privoxy/config #配置privoxy 通过/搜索listen-address 192.168.0.1:8118，然后将前面的#去掉，然后修改为listen-address 127.0.0.1:8118（端口号可以自行更改，后面同理）；同理，取消listen-address [::1]:8118前面的注释，不用修改。搜索forward-socks5t，然后取消注释（没找到可以新建一行），然后将内容修改为如下内容：1forward-socks5t / 127.0.0.1:1080 . 注意最后的那个点是必须写的。注意最后的那个点是必须写的。注意最后的那个点是必须写的。 重启privoxy1sudo service privoxy start 安装配置polipo如果你已经安装了privoxy可以跳过这一步。12sudo apt-get install poliposudo vim /etc/polipo/config 配置文件修改如下：1234567891011121314logSyslog = truelogFile = /var/log/polipo/polipo.logproxyAddress = &quot;0.0.0.0&quot;socksParentProxy = &quot;127.0.0.1:1080&quot;socksProxyType = socks5chunkHighMark = 50331648objectHighMark = 16384serverMaxSlots = 64serverSlots = 16serverSlots1 = 32 由于对polipo不是很了解，所以具体是什么意思我也不清楚。 重启polipo1sudo /etc/init.d/polipo restart 使用privoxy默认的HTTP代理端口是8118，使用polipo默认的HTTP代理端口是8123使用privoxy默认的HTTP代理端口是8118，使用polipo默认的HTTP代理端口是8123使用privoxy默认的HTTP代理端口是8118，使用polipo默认的HTTP代理端口是8123 剩下的就看你想怎么使用了，现在我的HTTP代理的端口是8118，如果我想让 apt 走代理，那么执行下面的操作配置环境变量123# 设置http 和 https 全局代理export http_proxy='http://localhost:8118'export https_proxy='http://localhost:8118' 取消代理：12unset http_proxyunset https_proxy 测试代理是否可用：1curl www.google.com.hk 如果有输出证明代理成功。 如果是像我一样拉LineageOS的源码编译，那么就给git配置代理，不用HTTP代理，直接使用SOCKS代理：12git config --global http.proxy 'socks5://127.0.0.1:1080'git config --global https.proxy 'socks5://127.0.0.1:1080' 取消代理：12git config --global --unset http.proxygit config --global --unset https.proxy 至此，本文完~]]></content>
  </entry>
  <entry>
    <title><![CDATA[LCS（最长公共子序列）求解]]></title>
    <url>%2F2018%2F05%2F21%2FLCS%EF%BC%88%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[废话因为四月份的蓝桥杯省赛拿了省一等奖，也报了国赛，加上6月2号的ACM，所以在这段时间里面要搞搞算法。这段时间的面试（只面了京东（校招）和头条（内推）），暴露出来的是Java基础了解的不够深入，同时算法一直以来都是我的薄弱环节，希望这两个比赛能够让我得到一点提升。这篇文章是为了我能够记住解题的思想同时也算是整理一下思路。 什么是LCSLCS(Longest Common Subsequence)——最长公共子序列 定义一个序列S任意删除若干个字符得到新序列T，则T叫做S的子序列。两个序列X和Y的公共子序列中，长度最长的那个，定义为X和Y的最长公共子序列。 这里主要区分一下子序列和子串（最长公共子序列和最长公共子串），最长公共字串要求连续字符串 “13455” 与 “245576” 的最长公共子序列为“455”。字符串“acdfg”与“adfc”的最长公共子序列为“adf”。 LCS的意义主要运用于比对的地方，比如图形的相似处理、媒体流的相似比较等。生物学家常常利用该算法景象基因序列比对，由此推测序列的结构、功能和演化过程。LCS可以用来描述两段文字之间的“相似度”，即它们的雷同程度，从而能够用来判断抄袭。另一方面，对一段文字进行修改之后，计算改动前后文字的最长公共子序列，将除此子序列外的部分提取出来，这种方法判断修改的部分，往往十分准确。 求解——暴力法最简单的想法便是列出字符串X的所有子序列，同时列出字符串Y的所有子序列，然后求出这两个字符串的所有子序列相同且最长的一个，便是最长公共子序列。加入字符串X的长度是m，字符串Y的长度是n，那么X共有\(2^m\)个不同子序列，Y有\(2^n\)个不同子序列，同时进行遍历，那么时间复杂度为O(\(2^m*2^n\))。显然，这是不可取的。 LCS解法探索在这里，我们先做几个定义： 假定字符串X，长度为m，从1开始数； 假定字符串Y，长度为n，从1开始数； Xi=&lt;x1,x2,···,xi&gt;即X序列的前i个字符(1&lt;i&lt;m); Yj=&lt;y1,y2,···,yj&gt;即Y序列的前j个字符(1&lt;j&lt;n&gt;); LCS(X,Y)为字符串X和Y的最长公共子序列，即Z=&lt;z1,z2,···,zk&gt;; 事实上，X和Y的可能存在多个子串，长度相同并且最大，因此，LCS(X,Y)严格的说，是个字符串集合。即：Z∈ LCS(X , Y) 在这里我们进行如下分析： 第一种情况：\(x_m=y_n\)(最后一个字符相同)则：\(X_m\)与\(Y_n\)的最长公共子序列\(Z_k\)的最后一个字符必定是\(X_m\)(\(Y_n\));此时，\(Z_k\)=\(X_m\)=\(Y_n\)LCS(\(X_m\),\(Y_n\))=LCS(\(X_{m-1}\),\(Y_{n-1}\))+\(X_m\) 举例： 1 2 3 4 5 6 7 X B D C A B A Y A B C B D A B 对于上面的字符串X和Y，\(x_3=y_3\)=’C’，则：LCS(BDC,ABC)=LCS(BD,AB)+‘C’\(x_5=y_4\)=’B’，则：LCS(BDCAB,ABCB)=LCS(BDCA,ABC)+‘B’ 第二种情况：\(x_m{\ne}y_n\)此时又分为两种情况： LCS(\(X_m\),\(Y_n\))=LCS(\(X_{m-1}\), \(Y_n\)) LCS(\(X_m\),\(Y_n\))=LCS(\(X_m\), \(Y_{n-1}\)) 证明：令\(Z_k\)=LCS(\(X_m\),\(Y_n\))；由于\(x_m{\ne}y_n\)，则\(z_k{\ne}x_m\)与\(z_k{\ne}y_n\)至少有一个必然成立，不妨假定\(z_k{\ne}x_m\)（\(z_k{\ne}y_n\)的分析与之类似）。因为\(z_k{\ne}x_m\)，则最长公共子序列\(Z_k\)是\(X_{m-1}\)和\(Y_n\)得到的，即： \(Z_k\)=LCS(\(X_{m-1}\), \(Y_n\))同理，若\(z_k{\ne}y_n\)，则\(Z_k\)=LCS(\(X_m\), \(Y_{n-1}\)) 即：若\(x_m{\ne}y_n\)，则：LCS(\(X_m\),\(Y_n\))= max{LCS(\(X_{m-1}\), \(Y_n\)),LCS(\(X_m\), \(Y_{n-1}\))} 举例： 1 2 3 4 5 6 7 X B D C A B A Y A B C B D A B 对于字符串X和字符串Y：\(x_2{/ne}y_2\)，则：LCS(BD,AB)=max{ LCS(BD,A), LCS(B, AB) }\(x_4{/ne}y_5\)，则：LCS(BDCA,ABCBD)=max{ LCS(BDCA,ABCB), LCS(BDC,ABCBD) } 因此： 编码实现我们使用一个二位数组用来C[m,n]来存储子序列的长度，c[i,j]记录了\(X_i\)和\(Y_j\)的最长公共子序列的长度。当i=0或者j=0是，空序列是\(X_i\)和\(Y_j\)的最长公共子序列，故c[i,j]=0。 使用另一个二维数组B[m,n]，用于标记c[i,j]的值是由哪个子问题的解得到的。即c[i,j]是由c[i-1,j-1]+1或者c[i-1,j]或者c[i,j-1]的哪一个得到的。取值范围为Left、Top、LeftTop三种情况。 举例：X=&lt; A，B，C，B，D，A，B &gt;Y=&lt; B，D，C，A，B，A &gt;最终得到的两个二维数组如图所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LCS &#123; private String str1 = "BDCABAGF"; private String str2 = "ABCBDABFG"; private static final int TOP = 1; private static final int LEFT = 2; private static final int LEFT_TOP = 3; public String lcs() &#123; int[][] C = new int[str2.length() + 1][str1.length() + 1]; int[][] M = new int[str2.length() + 1][str1.length() + 1]; for (int i = 1; i &lt;= str2.length(); i++) for (int j = 1; j &lt;= str1.length(); j++) &#123; char x = str2.charAt(i - 1); char y = str1.charAt(j - 1); if (x == y) &#123; C[i][j] = C[i - 1][j - 1] + 1; M[i][j] = LEFT_TOP; &#125; else &#123; int max = Integer.max(C[i - 1][j], C[i][j - 1]); if (max == C[i - 1][j]) M[i][j] = TOP; else M[i][j] = LEFT; C[i][j] = max; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); int i = str2.length(); int j = str1.length(); while (M[i][j] != 0) &#123; if (M[i][j] == LEFT_TOP) &#123; stringBuilder.append(str2.charAt(i - 1)); &#125; if (M[i][j] == LEFT_TOP) &#123; i--; j--; &#125; else if (M[i][j] == LEFT) j--; else if (M[i][j] == TOP) i--; &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; LCS lcs = new LCS(); System.out.println(lcs.lcs()); &#125;&#125; 在这里，lcs()返回的是最长的公共子序列，但是我没有做处理，此时返回的字符串是反向的，因为我们最后在通过方向数组寻找子序列的时候，是从后往前，所以这里的字符串是反向的。在这里给出伪代码实现： 说在后面在这里，这个算法依旧可以继续优化，但是由于我还没有搞清楚优化的原理，所以暂时不写，如果有需要的可以查看参考链接获取更多信息。 参考链接十分钟搞定LCS - 七月在线]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android路线图]]></title>
    <url>%2F2018%2F05%2F07%2FAndroid%E8%B7%AF%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Java部分（基础）基础部分1 https://www.imooc.com/learn/85 基本的语句（if else这些） 数组，函数 基础部分2 https://www.imooc.com/learn/124 类和对象（构造函数、静态变量、静态方法） 继承（方法重写、抽象类） 接口 基础部分3 集合，泛型，Map，迭代器（Iterator） 常用的工具类（String、File、Date、Calendar、） 异常处理（try……catch） 输入输出流（可以后面在Android需要时学习） 多线程（可以后面在Android需要时学习） Android（基础）https://www.imooc.com/course/programdetail/pid/33 把这个路径收藏了 AndroidManifest.xml是什么，项目的结构 五大布局（布局可以嵌套，达到的层次是给你随便一个界面，你知道该怎么写）、可以去看一下约束布局ConstraintLayout任务：计算器布局、登录页面 Activity（生命周期了解，启动模式了解） intent传递数据（各种数据怎么传，一个对象怎么传） 基础控件（TextView、EditText、ImageView、ImageButton、CheckBox、RadioButton、RadioGroup、Switch等），事件监听 高级控件1（ListView（同时了解MVC，了解就好）、RecyclerView）https://www.imooc.com/learn/365上面的那个链接看看，第一行代码上的自定义Adapter不用看了，直接看继承BaseAdapter的任务：写两个Activity，第一个Activity加载一个List，然后通过intent传递这个list到第二个Activity，然后再第二个Activity使用ListView以及RecyclerView加载显示（考察activity、基础控件、intent） 高级控件2（DatePicker、TimePicker、GridView、Spinner、ProgressBar）任务：一个简易的闹钟APP（只需要实现时间的选择【日期选择、时间选择】，比如说一个界面设置闹钟，然后跳转第二个界面，把那个数据显示一下） Service（如何注册服务，怎样启动服务，怎样绑定服务，启动服务和绑定服务的区别和联系，掌握服务的生命周期）、IntentService可以去看一下任务：一个Activity，单击按钮启动Service，然后Service里面使用MediaPlayer播放音乐（放在APP里面的assert文件夹） 对话框（Dialog）、Toast、Snackbar、菜单（Menu） Fragment（Fragment的生命周期，以及Fragment与Activity之间的相互通信）（如果感觉不是很好理解，可以忽略一些东西） ViewPager、ScrollView任务：一个启动页，带底部的小红点 数据存储（文件、SharedPreference、数据库）任务：1.把以前写的闹钟APP写成能用的；2.登陆的界面逻辑实现、自动登陆、登录状态的存储 广播接收器、内容提供者（会写） 多线程（Thread、Handler、异步操作）任务：Java实现一个多线程卖票（四个窗口同时卖100张票） 网络（网络请求、WebView的使用） 动画，绘图 事件分发机制 自定义View、自定义ViewGroup额外：Git-版本控制工具额外：Material Design（Google的界面设计规范） 基础部分肯定不止这么一些东西，另外的东西如果需要可以去学习，按情况学习。这个时候，你去开发任何一个APP都是能够写出来了的，再加点框架，就可以堆项目经验了。框架推荐：Okhttp，Volley，Glide，AsyncTask，LitePal，RxJava，RxAndroid，Retrofit这些框架有些是重复的，按需学习 Java高级这块就6p了，我这里只提要点，到这个时候你们会知道是些什么东西的，没有先后顺序要求 面向对象和面向过程的思想 线程、线程池 类的加载流程（双亲委托模型），加载方式 内存的管理机制，内存回收算法（引用计数、标记-清除、复制算法、标记-压缩、分代）、内存泄漏 等等 Android中高级不分先后顺序 四大组件生命周期，启动流程 架构：MVC、MVP、MVVM IPC（跨进程通信） 性能优化 NDK开发 各种东西的高级用法 Gradle开发（可选） 其他方面 Kotlin（开发语言） 设计模式（全语言通用） Android系统相关，如果你感兴趣的话会自己去搞的（Xposed，Magisk，SU，修改源码以及编译Android）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK安装与配置以及Android Studio安装与配置]]></title>
    <url>%2F2018%2F04%2F10%2FJDK%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8AAndroid-Studio%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[#不想多说什么，直接开始主题。 JDK安装与配置JDK下载 打开你的浏览器，不管你是Chrome还是Firefox还是Edge还是Internet Explore，只要是个浏览器就打开。 打开这个地址： http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html（JDK下载地址） 找到下面的地方，然后根据图片操作。在这里根据自己系统的位数进行下载，比如我的系统是64位的就下载64位的安装包。如果不知道怎么查看自己系统的位数，请查看这个链接：https://jingyan.baidu.com/article/0bc808fc6b49c21bd485b90d.html 使用下载工具，略JDK安装下载JDK安装包应该已经下载到本地了。这个就是下载下来的JDK安装包，我给的链接是JDK1.8的，我下载的是64位的 打开，双击还是右键打开随你。 请跟随下面的流程进行操作：一打开就是这个界面。接下来是选择安装那些东西和安装的位置，具体操作我也在图片里标注了，至于安装位置，在不在C盘都行，只是路径里面尽量不要有空格，有空格也可以，只是稍稍麻烦一点而已。单击继续之后开始安装JDK，注意的是JDK在安装的最后会安装JRE，如果你已经安装了可以不用安装。选择安装路径安装好JRE之后JDK也会提示安装完成。JDK环境变量配置似乎这一步对于Android Studio来说可有可无（我没配置环境变量依旧可用AS），考虑到以后各位可能要学Java，提前搭建环境也是可以的 打开环境变量配置首先鼠标右键计算机（或者此电脑，或者你自己改的名字），选择属性。会进入到下面的界面，如果找不到计算机、此电脑、奇葩名字的，可以通过win键（或者点一下开始菜单），然后输入“控制面板”（英语请输入”Control Panel”），打开之后依次打开“系统和安全”(System and Security)-“系统”(System)进入下面的界面。如图所示打开“高级系统设置”然后打开“环境变量” 配置JAVA_HOME如图操作：关于JDK的安装路径，是我们在上一个步骤自己选择的，可以使用“文件资源管理器”定位到目录，然后拷贝路径： 配置PathPath变量和JAVA_HOME不同，这个变量是系统已经有的，所以我们只需要更改它的值就行，不用新建，如图操作：依次添加两个值： %JAVA_HOME%\bin %JAVA_HOME%\jre\bin 配置CLASSPATH如图： .;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar 复制的时候不要忘了前面的那个点复制的时候不要忘了前面的那个点复制的时候不要忘了前面的那个点 测试JDK的环境变量打开CMD，PowerShell也行，然后输入java或者javac，如果不是提示未知命令则配置成功。至此，JDK的下载安装配置完成。Android Studio下载安装与配置下载Android Studio首先，让我们感谢伟大的万里长城，默念社会主义好。因为某些不可描述（我也不想描述）的原因，google.com是404 Not Found的，但是Google发布了中国站点developers.google.cn。反正我们是能用了。这里给出Android的开发网址，里面包含了最新的blog以及一些其他的东西，比如说Kotlin。https://developer.android.google.cn/develop/index.html 下载Android StudioAndroid Studio下载地址：https://developer.android.google.cn/studio/index.html不用去担心什么被墙了，这个没有，也不推荐去各大应用市场下载，鬼知道它的是哪个版本的，也不知道是不是改过什么的。在这里我下载的是第一个，64位，exe的版本。下载下来就这个样子，忽略我的版本号。 安装Android Studio双击打开，依次执行：关于是否安装到C盘的问题，随你，因为我C盘是固态硬盘，本着固态硬盘是拿来用的，不是拿来看的思想，所以我的软件都是装在C盘的。之后的安装界面应该是没什么重要的了，一直默认就行，因为我已经安装了Android Studio，所以，就没有继续安装。 配置Android Studio安装完之后，你应该可以在桌面或者开始菜单中找到Android Studio的图标。打开之后会出现下面的界面：这是在询问你是否要导入旧版本的配置，因为我们是第一次安装，所以选择不导入（Do not import settings）Android Studio启动界面第一次安装的时候会出现这个弹框，这是因为我们还没有下载Android SDK。等那个界面过了之后，我们会进入这个界面,依次执行具体的操作我都标注在了图里面，依次来就行。最后会进入SDK的下载界面，不用担心什么被墙了之类的，dl.google.com解析到的是Google在北京的服务器，没被墙。等待SDK下载完毕之后就可以使用Android Studio了。至此，Android Studio下载安装配置完成。使用Android Studio来进行Hello World 打开Android Studio也许你的打开之后没有左边的一堆东西，那是你打开过的历史项目，而在我这里就是一些我自己写的项目，可以看到西瓜课表也在里面。在这里，我们选择新建一个项目。如果某个时刻卡在了Building &#39;XXXXX&#39; Gradle project info，请等待，一般是因为在下载Gradle，又因为Gradle在国内的访问速度被限制，所以我们等待就好，也许上一节课回来就ojbk了。当然，如果你觉得自己的动手能力很强，可以尝试这个文章的方法手动下载Gradle。其他的问题基本上可以尝试Google或者Bing或者Baidu（不推荐，有些东西，真正能解决问题的因为国情就XXX了）。参考链接Android studio安装与配置 - hebbely如何自学Android - lavor慕课网 Android工程师路径图Android代码规范 - xlsong阅读《阿里巴巴Android开发手册1.0.1》笔记 - woodsho]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio安装</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的一年，新的打算]]></title>
    <url>%2F2018%2F03%2F21%2F%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%96%B0%E7%9A%84%E6%89%93%E7%AE%97%2F</url>
    <content type="text"><![CDATA[总算是有点时间来写博客了。距离上篇文章已经过去好几个月，这几个月主要在忙写课表和其他的项目，此外就是作业。趁着有时间，也把博客更新了一遍，从Material换到Next，把文章中的图片全部放到CDN里面。 现阶段的情况不管怎么算，笔者也是大三了，怎么说也要为了实习工作打算。之后的时间大概如下安排： Android基础知识复习（四大组件生命周期、启动） MVC,MVP,MVVM 网络连接，IPC，APP优化，动画，框架 新版本的新特性 Kotlin的系统学习 刷题（算法，笔试） 希望还来得及吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装的三种方式]]></title>
    <url>%2F2017%2F09%2F06%2FUbuntu%E5%AE%89%E8%A3%85%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多图预警！！！！说在前面关于Linux的历史，网络上或者书上有很多资料，简单了解就行了。在这里我主要是讲一下Linux的安装，包括虚拟机的安装，双系统的安装以及ubuntu on windows的操作。 虚拟机的安装安装虚拟机软件虚拟机软件有Vmware Workstation，VirtualBox等，在这里，我主要介绍使用Vmware Workstation安装过程。首先，这里是Vmware Workstation的下载链接。（正版什么的，有钱就支持，没钱就乖乖用着盗版别bb，用盗版还有优越感的话，那是你有毛病。）下载完毕之后点击安装Vmware Workstation。安装过程我想不用多说了…… 下载Ubuntu镜像其实不一定非要是Ubuntu的镜像，用Centos或者其他的也可以。 Ubuntu官网：http://www.ubuntu.org.cn/global（国际版）最新版下载链接（17.04） 优麒麟官网：http://www.ubuntukylin.com/ Centos官网：https://www.centos.org/最新版下载链接 自己使用下载工具进行下载。 使用Vmware Workstation安装Ubuntu关于教程的通用性，安装界面不同，安装之后的界面也不同，对于用虚拟机安装Ubuntu的方式，就和自己电脑安装windows或者重装系统一样的操作，在这里我只是简单讲一下。 在这里，请选择存储为单个文件。 创建完成之后，由于勾选了创建完成之后打开虚拟机，所以，会自动启动虚拟机进行安装。安装完成之后就能打开进行使用了。如果出现错误的话，请Google。 双系统的安装方式（正戏）制作U盘启动盘其实不一定非要做成启动盘，刻碟应该也是可以的。但是有时候为了灵活一点就把u盘做启动盘更方便。 下载想要写入的镜像请参考这里 下载安装UltraISO（软碟通）官网地址下载 制作启动盘下载安装后，它会自动注册位iso文件的默认打开方式。这时我们只需要双击下载的iso文件就能打开软碟通的界面。然后执行下面的操作： !!!注意，格式化操作会清空U盘的上的所有文件，请提前做好备份!!! 至此，U盘启动盘制作完毕。 磁盘分区一般来说，电脑安装了Windows之后，磁盘都是已经分好区的，一般是NTFS文件系统，但是Linux并不能用NTFS来进行安装，所以我们需要从硬盘中分出一部分空间来安装Linux。磁盘管理有很多软件，比如PE里面经常用的DiskGenius，其实windows也自带了磁盘管理的功能。右键开始菜单按钮，然后选择磁盘管理。 如果需要DiskGenius的话，可以去官网下载。这里就列出了我电脑的所有分区： 其中C、D、E盘是NTFS文件系统，挂载了/（Linux根目录）和/home的是Ext4文件系统，swap是Linux的交换分区。切换到DiskGenius，可以看到文件系统的信息。 像我这个是分好区并且已经安装了双系统的。没有分区的话，就找出一块空闲的空间，比如D盘或者E盘的剩余空间，因为分区的时候会卸载和挂载分区，所以在Windows启动的情况，你是无法从C盘分出空间的。如果真的想从C盘分，请自己制作PE启动盘，然后进入PE使用DiskGenius进行操作。在这里，我以D盘为例，从D盘分出一块100G的空间来。备注：Linux的话分个几十个G就够了，如果你只是想玩玩的话，具体情况还是看你自己。比如我这里分了300G给/home是因为但是我需要编译Android，源码占用20G，编译后占用100G+，所以分了300G。一般来说，50个G应该是够了的，如果以后觉得不够了，可以在不格式化分区的情况下重装系统，这样数据都会在的。 开始分区使用DiskGenius的话是右键对应的分区，然后选择拆分分区。 分区之后就是这个样子： Windows自带的磁盘管理操作也差不多。右键D盘的分区，然后选择压缩卷。 分出来之后直接就是空闲分区，我们不需要更改了。 禁用安全启动对于快速启动是否禁用，我在这里持可选态度，像我没有禁用快速启动依旧可以正常的引导Deepin和Windows。不过安全启动是一定需要禁止的。最简单的办法是进入BIOS然后在boot页禁用secure boot（安全启动）。不同的设备进入BIOS的方法不同。（自行Google品牌或型号） 更改启动菜单或者从U盘启动其实修改启动菜单的原因就是为了让电脑从U盘启动，然后我们就能安装系统，不然的话，默认进入Windows的分区，连安装界面我们都看不到。具体的修改办法是在BIOS的Start Up页切换顺序，如下图： 备注：安装完Ubuntu之后，把启动项恢复为原样，或者拔掉U盘，不然下一次开机依旧会进入U盘启动盘。 当然，也可以在开机的时候选择启动项，比如说我在的电脑在开机的时候按ESC能进入启动项的选择菜单，然后选择我们制作的U盘启动即可。 选择语言——中文，英语随意。 这个的话可以勾上，也可以不勾，下载更新因为我们是离线安装，所以无法勾选。 在这个界面，如果想简便操作的话可以直接选择第一个，将Ubuntu和Win10共存，我曾经测试过一次，没出问题，但是我不敢保证绝对没问题，为了保险起见，我们还是选择其他选项，手动来安装Ubuntu。 空闲空间分区还记得我们在Windows分出来的空闲空间吗，当时是处于未分配的状态，所以，为了安装Ubuntu，我们需要在这个安装界面对那一块空间进行分区。正如我之前展示我的已经装好双系统的样子，我给Linux（Deepin）分的是四个分区，分别挂载为/，/home，/boot和swap，其实Linux不止这四个挂载点，只是我们一般只要挂载这四个就足够了，其他的会自动从/分出空间去。 下面是Linux的分区的介绍：/（根目录）：所有未指定挂载点的目录都会放到这个挂载点下。/boot：boot目录包含了操作系统的内核和在启动系统过程中所要用到的文件。/home：一般每个用户100M左右，特殊用途，比如放大文件也可再加上G。分区大小取决于用户多少。对于多用户使用的电脑，建议把/home独立出来，而且还可以很好地控制普通用户权限等，比如对用户或者用户组实行磁盘配额限制、用户权限访问等。/tmp：临时文件目录。/usr：大部分的用户安装的软件程序都在这里。就像是Windows目录和Program Files目录。很多Linux家族系统有时还会把/usr/local单独作为挂载点使用。/var：包含系统运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化的，系统日志记录也在/var/log下。一般多用户系统或者网络服务器要建立这个分区，设立这个分区，对系统日志的维护很有帮助。/srv：用来存放service服务启动所需的文件资料目录，不常改变。/opt：存放可选的安装文件，个人一般把自己下载的软件资料存在里面。/bin：存放二进制可执行程序，里面的程序可以直接通过命令行调用，而不需要进入程序所在的文件夹。/sbin：存放标准系统管理员文件。/dev：驱动文件等。swap：交换分区，不是挂载点，swap指定大小可根据内存大致确定，4G以下内存，swap 设置为内存的2倍。4-8G内存，swap 等于内存大小。8-64G内存，swap 设置为8G即可。 分区的大小之类的，看自己，像我分个四个分区，/boot给个几百m就行了（我给了1G……），swap照着上面的来（我给的10G，电脑内存8G……），/给20G就行了（我给的30G……），/home把剩下的全给了（我给的300G，因为特殊需求）。当然，我在这里演示的，切出来的分区大小是50G，分配的方案是：swap8G，/boot200M，/20G，剩下的全给/home。关于分区类型，如果是mbr分区，主分区是限制4个的，win10使用的是gpt分区，efi引导，所以并没有这个限制。然后选择/boot对应的盘符作为“安装启动引导器的设备”，务必保证一致。备注：如果电脑支持UEFI，换句话说，如果电脑预装系统是win 8以上就支持，不需要用工具特意添加启动项，只需要在Unbutu分区的时候，将启动引导器设置为esp分区就好，就是存放windows启动项的分区，很好辨认，大小为100MB左右，分区格式为fast16的就是。这种方法有一个前提，就是安装的Linux发行版支持uefi,用压缩工具打开镜像，里边有一个efi的文件夹就是支持，Ubnutu的话是64位支持，这是Ubuntu引导启动。如果要卸载Ubuntu，进入BIOS把默认启动项设置为Windows然后再删掉Ubuntu的分区即可。 分区完成之后如下图所示。（下面的swap那些是我的另一个Linux系统……） 接下来需要设置Ubuntu的用户信息，用户名，密码，计算机名。 然后就等着安装吧。 安装完毕之后会提示重启。 这时重启会首先出现这样一个界面，这是Ubuntu的grub引导，默认采用的是Ubuntu引导Windows。 登陆用户。 至于引导方式，如果你的电脑是UEFI启动，就用Ubuntu来引导Windows，如果不是的话，可以使用Windows来引导Ubuntu（引导界面不错，具体方法自行Google，因为我也没玩过），由于我的电脑是UEFI启动，所以一直都是使用Deepin来引导Windows。备注：查了一下资料，好像win10都是efi引导，gpt分区，没有办法使用windows来引导Ubuntu，bios中设置windows manager为第一启动项的话，会直接启动到windows，如果设置为ubuntu，会出现grub引导，在这个界面可以选择启动windows还是ubuntu。至此，双系统安装Ubuntu的方式介绍完毕。 Ubuntu on windows2016年3月30日在美国旧金山的莫斯康展览中心，微软召开了 Build 2016开发者大会，大会上微软除了介绍自家生态系统的产品与技术外，还为开发者带来了 Ubuntu on Windows 功能。Bash 是 Linux/Unix 上非常流行的命令行Shell，它是 Ubuntu、RHEL 等 Linux 发行版以及苹果 OS X 操作系统默认的命令行 Shell。Bash on Ubuntu on Windows 功能主要是面向于开发者，尤其是 Web 开发者或者参与某些开源项目的开发者，他们可以在 Windows 中使用一些 Linux 生态链的开发工具。刚发布的时候是需要使用预览版才能启用的，但是现在的话应该都能启用了。要求是版本号大于Build 14316如下图是我的Windows版本号：15063.540 接下来，我们就开始启用这个功能。 打开开发者模式依次在“设置”-“更新与安全”-“针对开发人员”选项中，启用开发人员模式. 启用功能然后在 控制面板 &gt; 程序 &gt; 程序和功能 &gt; 打开和关闭Windows功能中勾选Windows Subsystem for Linux (Beta) 然后重启。 安装BashWin+R 运行cmd，然后输入bash，会提示安装。当然，我这里是很早就安装了的，所以安装的过程什么的，照着来就行了。 当然，这个是没有界面的，就只有一个shell，拿来学习bash shell还是不错的。 至此，三个方法介绍完毕。 其实还有第四个方法不过不算是安装，你去弄一台Linux的主机，然后ssh上去不就行了？ 参考链接VMware Ubuntu安装详细过程 Windows10+Ubuntu双系统安装[多图] Bash on Windows 10 怎么安装？ Win10运行Ubuntu版Bash]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LineageOS移植Pixel导航栏动画]]></title>
    <url>%2F2017%2F07%2F14%2FLineageOS%E7%A7%BB%E6%A4%8DPixel%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[前言Google Pixel &amp; Pixel XL是Google在2016年10月4日推出的全新Android智能手机，接任之前的Nexus系列，也是Pixel系列首次推出智能手机产品；于东8区时间2016年10月5日凌晨的Google秋季发布会上正式公布。可以说对于Pixel系列，大多数人都不陌生，Pixel系列作为最先搭载Android N操作系统的移动终端系列，除了Android N之外，还有独享的Pixel Launcher以及Google Assistant。当然，对于现在（2017/07/14）来说，Pixel Launcher和Google Assistant都不再是Pixel系列独享了，但是依旧有很多人对于Pixel依旧独享的导航栏动画非常感兴趣。同理，我也很喜欢那个动画，从我去年十二月份刚开始使用Android N，我使用的Nexus 6在XDA论坛有一个大神做了一盒mod整合包（参考地址），包括网速显示，Pixel开机动画，Pixel导航栏动画等，从那时候开始，我便一直在使用这个mod，直到今年4月份。那个时候我不太喜欢那位大神的网速显示，然后就自己拿着LineageOS源码添加网速显示，并且取得了成功，从那之后我便一直使用自编译的系统直到现在。网速显示，开机动画这些我都自己添加到源码中了，没有添加的也做成了mod包。只有导航栏动画我没找到办法。 办法两个月前，我只找到一个教程，就是通过反编译SystemUI.apk然后移植动画，对于这种方法，我是觉得太过于麻烦了，而且从某一个版本开始，我回编译SystemUI.apk不能成功了，所以这种办法我直接放弃。虽然决定了放弃，但是并不是说这种办法不可行，而我也简单研究了一下这种方法需要修改什么东西。总共需要改以下东西： home键的布局文件——home.xml dimens.xml ids.xml styles.xml 大部分的java代码可以看出来，前四样都是布局相关的，直接反编译pixel的apk也能得到数据，但是最重要的是第五样，home.xml中将KeyButtonView用了一个叫做OpaLayout的控件包起来，而我想在源码层一劳永逸的话，必须要搞到java代码而不是smali。这也是我当初放弃了的原因。这里是当初我找到的反编译修改的方法：[Guide] How to Port Pixel Navigation Bar Animation to Your Phone (Updated to 7.1.1 Final)没找到相应的java代码，也没找到pixel的源码，所以就暂时搁置了。直到今天。隔几天我就喜欢进xda论坛看看有没有什么有趣的东西或者rom，mod之类的，但是今天下午我看到了一个rom——DARK ROM 14.1而在这个rom的简介中列出了pixel的导航栏动画： Key features Full OMS support (rootless) Signature spoofing support Pixel Launcher (with the provided GAPPS package) Pixel animated navbar (with on/off switch) Pixel sounds Pixel accent colors Pixel bootanimation with sound Rounded icons Google Assistant Night Light Night Light Brightness Choose between dialer and voice assistant in lockscreen Hide next alarm from expanded status bar and lockscreen Disable the boot animation sound Secure lockscreen (disables status bar pull down, quick settings tiles, power button and lockscreen shortcuts) Double tap the lock icon on the lockscreen to sleep Longpress power button while screen off to trigger flashlight Hide bluetooth icon when disconnected Volume steps Quick unlock pin/password Remove album art from lockscreen Date in status bar Battery bar Custom headers Smart pulldown Volume button controls media volume anywhere Change navbar height Screenshot tile Caffeine tile Sync tile Reboot/recovery tile Music tile USB Tethering tile NFC tile Quick settings custom rows/columns Turn on/off mobile data with single click on collapsed quick settings Status bar ticker Separate ring and notification volume Specific color for 100% charged battery Prevent accidental wakeup Remove settings suggestions Show WiFi SSID in status bar Show carrier label in status bar Hide carrier label when WiFi SSID is showing Hide carrier label on the lockscreen (or rename to whatever you want) Hide the low battery warning notification Remove the orange status bar and navigation bar when in battery saver mode One hand mode Choose doze brightness Adjust animation scale precisely with a slider Dynamic nav bar color (changes color to the same of status bar) In-call vibration options (on connect, on call waiting and on disconnect) 可以说是很强大了，但是我关注的是pixel的导航栏动画。简单翻了一下，下面居然有github地址，也就是说有pixel导航栏动画的源码。后来也就猜到了，我找到了对应的OpaLayout.java文件，然后添加到我的源码中，修改，编译，成功。这里留下这个rom在nexus 6的帖子：[ROM][LOS14.1][7.1.2_r24] DARK ROM [OMS][Pixel features][Delta updates] 具体修改OpaLayout.java上面的就是这个rom中的OpaLayout.java文件了。但是直接添加进去是无法使用的。由于不知道这个rom是什么样子的，所以我直接把文件扔进源码编译了，我相信编译器会告诉我哪里错了。果不其然，编译的时候提示我第100行和614行有错误。告诉我找不到CMSettings.System.PIXEL_NAV_ANIMATION，看起来这个应该是设置项什么的，而我想要的是一直显示，自然不需要一个开关，所以我去掉了设置相关的代码，并且在setOpaEnabled方法中设置为一直显示。编译，成功。最后放上我修改过的OpaLayout.java源文件。其他布局相关的修改可以参照反编译的方法中的代码。 参考列表[Guide] How to Port Pixel Navigation Bar Animation to Your PhoneCool Pixel Mod for StockOS - Android 7.1.1 / LineageOS - Android 7.1.2[ROM][LOS14.1][7.1.2_r24] DARK ROM [OMS][Pixel features]LineageOS/android_frameworks_basedarkeyes84/android_frameworks_base]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Rom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西华大学学生外网访问教务管理系统]]></title>
    <url>%2F2017%2F07%2F05%2F%E8%A5%BF%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%AD%A6%E7%94%9F%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[说在前面前段时间，学校（西华大学）禁止了外网访问教务管理系统，但是在教务系统官网给出了一个外网访问的方法，虽然我也不清楚学校抽什么疯封了外网，但是既然已成事实也没办法。官网给出的解决方法是连接学校的vpn然后访问内网资源，只是这个文档有些地方是错误的（反正第一次操作没成功），加上有些同学一直在群里问外网怎么进教务系统，回答的烦了，就写一篇简单的教程，顺便刷点pv。 教程教程的方法是通过vpn，喜欢番茄的同学都懂这个东西，听说教育网没有被墙，那次我试了一下，可能是姿势不对，并没有成功出墙（跑偏了）。 访问https://vpn.xhu.edu.cn，首先出来的应该是提示安全证书有问题，不过学校既然让你用这个，老老实实继续浏览吧。点击浏览不安全的网站之后一闪而过的是下面的界面：然后就是让你下载EasyConnect了。低头低头，下载就下载。很明显，这玩意又装到c盘了。 运行EasyConnect全自动一键化操作，直接安装，然后在桌面丢了两个快捷方式。第二个好像是ie的快捷方式，不过ie被我干掉了，就没显示。双击运行，提示输入vpn地址，填：https://vpn.xhu.edu.cn下载组件什么的就下吧，毕竟要低头。关键来了，好多同学就是这里出问题，按照原教程的说法1用户名为职工号或学号，密码为对应职工号或学号的信息门户密码（即校园网统一身份认证密码）,初始密码是身份证号的后六位，如有X为大写。如果密码遗忘，请携带有效证件到信息与网络管理中心技术开发部(4C-307)重置密码。 有的同学又说输入了密码不对，那我们就去信息门户看看。传送门用户名为职工号或学号，密码为对应职工号或学号的信息门户密码（即校园网统一身份认证密码）,初始密码是身份证号的后六位，如有X为大写。这里我记得就是这样输入的不对？改个密码试试。其实我是记不清楚了，好像第一次登陆这里提示改密码，然后我改了之后就可以登陆vpn了。什么鬼……不管了，反正能用了。按照原教程的说法，连接之后双击图标（还是右键？），然后在跳出的界面点教务系统就能进了，至于截图，我没回家，所以一直在学校，本身不挂vpn都能进教务系统。至于一些其他的问题，不清楚，反正我这里是打不开vpn的什么页面，至于是不是什么奇怪的buff加成，不清楚。 手机端教程按照原教程的说法，手机端比pc端简单很多，不过我测试的时候并不是。原教程说的是通过进入vpn的网页，然后登陆就可以进了，和pc不同的是，我手机连接了那个什么vpn界面倒是加载出来了，不过点教务系统依旧没卵用。然后我照着pc的方式尝试（因为EasyConnect有手机端（Android和ios）） 下载EasyConnect：vpn跳转过去的地址Google Play商店地址AppStore地址官网地址？（不清楚真实性）（吐槽：首页的界面挺好看的，但是这个下载界面什么鬼） 下载安装之后，运行，和pc基本差不多，流程可以说完全一样。 值得一提的是，Android系统自带了vpn功能，那么能不能使用系统的vpn功能连接学校的vpn呢？反正我是没成功。下面是操作截图：很明显的一个UnSuccessful，未成功，我也不知道什么原因，不过既然通过一个App就能用的话，我也懒得折腾，也不会折腾。至此，教程完毕。推荐文章可能大家都慌着查成绩，但是那个教学测评很烦，在这里贴上一篇大神的博客，使用控制台自动填充选项并且自动提交（web很渣不知道对不对）。一起来摆脱教务系统强制教评的痛苦 - 简书]]></content>
      <categories>
        <category>学校的破事</category>
      </categories>
      <tags>
        <tag>西华大学</tag>
        <tag>外网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service Context MVC 简介]]></title>
    <url>%2F2017%2F06%2F08%2FService%20Context%20MVC%20%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[service概述后台运行，不可见，没有界面。（在activity中完成的事物，在服务中也可以完成） 优先级别高于activity 应用场景：eg: 后台播放音乐 后台下载应用 记录GPS位置 监听某一特定的动作 处理数据，处理当前不一定及时需要展现给用户的数据 进入应用时加载本地资源（数据库等） 在后台操作提高交互性 全家桶唤醒 …… 全家桶 生命周期 创建服务要创建服务，您必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，您需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括： onStartCommand()当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。）onBind()当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。onCreate()首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind()之前）。如果服务已在运行，则不会调用此方法。onDestroy()当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。 如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()），则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。 清单文件Manifest声明service跟activity以及其它组件一样，你必须在你的应用的manifest文件中声明所有的service。要声明你的service，添加一个&lt;service&gt;标签到&lt;application&gt;标签。例如：1234567&lt;application……&gt; &lt;activity ……&gt; &lt;/activity&gt; &lt;service android:name=".MyService"&gt; &lt;/service&gt;&lt;/application&gt; 启动服务 start方式：通过startService启动访问者与服务之间没有关连，即使访问者退出了，服务仍然运行。调用create，onstartcommand方法。 bind方式：通过bindService启动访问者与服务绑定在了一起，访问者一旦退出，服务也就终止。 PS：如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。 应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象 （指定服务并包含待使用服务的所有数据）来启动服务。服务通过onStartCommand() 方法接收此 Intent。 两种方式启动服务的区别:通过startService()和stopService()启动关闭服务。适用于服务和访问者之间没有交互的情况。如果服务和访问者之间需要方法调用或者传递参数，侧需要使用bindService()和unbindService()方法启动关闭服务。 采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法，这个时候访问者和服务绑定在一起。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。 如果访问者要与服务进行通信，那么，onBind()方法必须返回Ibinder对象。如果访问者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果访问者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。 停止服务系统不会停止或销毁service，除非内存不够用了，并且service在onStartCommand()返回后会继续运行．所以，service必须调用stopSelf()停止自己或由另一个组件调用stopService()来停止它。 一旦通过stopSelf()或stopService()发出了停止请求，系统就会尽可能快地销毁service． 然而，同时使用 startService 与 bindService 要注意到，Service 的终止，需要unbindService与stopService同时调用，才能终止 Service，不管 startService 与 bindService 的调用顺序，如果先调用 unbindService 此时服务不会自动终止，再调用 stopService 之后服务才会停止，如果先调用 stopService 此时服务也不会终止，而再调用 unbindService 或者 之前调用 bindService 的 Context 不存在了（如Activity 被 finish 的时候）之后服务才会自动停止。 注意：你的应用在完成工作后停止它所有的service是非常重要的．这可以避免浪费系统资源和消耗电量．如果需要，其它的组件可以调用stopService()停止service．即使你为service启用了绑定，你也必须自己停止service，甚至它收到了对onStartCommand()的调用也这样。 Context概念它描述的是一个应用程序环境的信息，即上下文。该类是一个抽象(abstract class)类，Android提供了该抽象类的具体实现类(后面我们会讲到是ContextIml类)。通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如：启动一个Activity，发送广播，接收Intent等。 Context相关类的继承关系 Context的类型以及在四大组件中的实现 Application － 是一个运行在你的应用进程中的单例。在Activity或者Service中，它可以通过getApplication()函数获得，或者人和继承于context的对象中，通过getApplicationContext()方法获得。不管你是通过何种方法在哪里获得的，在一个进程内，你总是获得到同一个实例。 Activity/Service － 继承于ContextWrapper，它实现了与context同样API，但是代理这些方法调用到内部隐藏的Context实例，即我们所知道的基础context。任何时候当系统创建一个新的Activity或者Service实例的时候，它也创建一个新的ContextImpl实例来做所有的繁重的工作。每一个Activity和Service以及其对应的基础context，对每个实例来说都是唯一的。 BroadcastReciver － 它本身不是context，也没有context在它里面，但是每当一个新的广播到达的时候，框架都传递一个context对象到onReceive()。这个context是一个ReceiverRestrictedContext实例，它有两个主要函数被禁掉：registerReceiver()和bindService()。这两个函数在BroadcastReceiver.onReceive()不允许调用。每次Receiver处理一个广播，传递进来的context都是一个新的实例。 ContentProvider － 它本身也不是一个Context，但是它可以通过getContext()函数给你一个Context对象。如果ContentProvider是在调用者的的本地（例如，在同一个应用进程），getContext()将返回的是Application单例。然而，如果调用这和ContentProvider在不同的进程的时候，它将返回一个新创建的实例代表这个Provider所运行的包。 经验法则绝大多数情况下，使用在你的所工作的组建内部能够直接获取的Context。只要这个引用没有超过这个组建的生命周期，你可以安全的保存这个引用。一旦你要保存一个context的引用，它超过了你的Activity或者Service的生命周期范围，甚至是暂时的，你就需要转换你的引用为Application context。 实例浅论一下context ： 在语句 AlertDialog.Builder builder = new AlertDialog.Builder(this); 中，要求传递的 参数就是一个context，在这里我们传入的是this，那么这个this究竟指的是什么呢？ 这里的this指的是Activity.this，是这个语句所在的Activity的this，是这个Activity 的上下文。网上有很多朋友在这里传入this.getApplicationContext（），这是不对的。 AlertDialog对象是依赖于一个View的，而View是和一个Activity对应的。 于是，这里涉及到一个生命周期的问题，this.getApplicationContext（）取的是这个应用程序的Context，Activity.this取的是这个Activity的Context，这两者的生命周期是不同 的，前者的生命周期是整个应用，后者的生命周期只是它所在的Activity。而AlertDialog应 该是属于一个Activity的，在Activity销毁的时候它也就销毁了，不会再存在；但是，如果传 入this.getApplicationContext（），就表示它的生命周期是整个应用程序，这显然超过了它 的生命周期了。 所以，在这里我们只能使用Activity的this。 总结getApplicationContext()返回应用的上下文，生命周期是整个应用，应用摧毁它才摧毁。 Activity.this返回当前activity的上下文，生命周期只是它所在的Activity，activity 摧毁他就摧毁 getBaseContext()返回由构造函数指定或setBaseContext()设置的上下文。 #MVC模型mvc模型简介MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。MVC模式最早由Trygve Reenskaug在1978年提出 ，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 界面设计人员进行图形界面设计。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 在android中最典型的MVC就是listview的显示M：model指你要显示的数据，如封装数据的cursor，array等等V：view：就是listView用来显示封装好的数据C：controller：就是adaptor，用来控制数据如何向listview中显示，如arrayadaptor，cursoradaptor等等 MVC好处：从用户的角度出发，用户可以根据自己的需求，选择自己合适的浏览数据的方式。比如说，对于一篇在线文档，用户可以选择以HTML网页的方式阅读，也可以选择以pdf的方式阅读。从开发者的角度，MVC把应用程序的逻辑层与界面是完全分开的，最大的好处是：界面设计人员可以直接参与到界面开发，程序员就可以把精力放在逻辑层上。而不是像以前那样，设计人员把所有的材料交给开发人员，由开发人员来实现界面。在Eclipes工具中开发Android采用了更加简单的方法，设计人员在DroidDraw中设计界面，以XML方式保存，在Eclipes中直接打开就可以看到设计人员设计的界面。 视图层（View）：一般采用XML文件进行界面的描述，使用的时候可以非常方便的引入。当然，如何你对Android了解的比较的多了话，就一定可以想到在Android中也可以使用JavaScript+HTML等的方式作为View层，当然这里需要进行Java和JavaScript之间的通信，幸运的是，Android提供了它们之间非常方便的通信实现。 在Android SDK中的数据绑定，也都是采用了与MVC框架类似的方法来显示数据。在控制层上将数据按照视图模型的要求（也就是Android SDK中的Adapter）封装就可以直接在视图模型上显示了，从而实现了数据绑定。比如显示Cursor中所有数据的ListActivity，其视图层就是一个ListView，将数据封装为ListAdapter，并传递给ListView，数据就在ListView中现实。 2.MVC与Android SDK MVC的基本原理就是通过Controller连接View和Model。也就是说，当View中显示的数据发生变化时，就会通知Controller，而不是直接通知Model，这时Controller接到View的通知后，会在Model中采取相应的动作来修改数据，使用MVC模式可以将数据和显示部分分离，这样修改一方时不会影响另一方，更有利于程序的维护。 在Android SDK中使用MVC的组件非常多，例如，列表控件ListView，GridView，Spinner等都采用MVC模式与数据交互，在Android中MVC中的V就是组件，M就代表着各种数据源，C代表Adapter类，包括BaseAdapter，SimpleAdapter，SimpleCursorAdapter，ArrayAdapter，CursorAdapter等。他们分别对应不同的数据源，这些Adapter都需要使用getView方法返回当前列表项显示的View对象，当Model发生改变的时候调用BaseAdapter.notifyDataSetChanged方法通知组件数据发生变化，这时Adapter会调用getView方法重新显示内容。总之无论是数据还是组件发生变化，都要通过Adapter这个桥梁来达到同步的目的。 参考文章Android Service详解 android四大组件–android service详解 推荐文章Android Context 上下文 你必须知道的一切 Android Context完全解析，你所不知道的Context的各种细节 框架模式 MVC 在Android中的使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
        <tag>Context</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译LineageOS]]></title>
    <url>%2F2017%2F04%2F23%2F%E7%BC%96%E8%AF%91LineageOS%2F</url>
    <content type="text"><![CDATA[说在前面之前一直想自己编译一次LineageOS，同时修改一些源码来自定义，然后在寒假折腾双系统，重新分区（原来的分区小了），然后升级配置之类的。最后在上个月成功编译了自己的第一个版本，编译的过程并不算难，网上很多流程，而且官方也有流程，所以一次编译成功了。只是这第一次编译花费了我3个小时。虽然说编译成功了说明我的机器编译还是没问题的，但是在编译的这三个小时里，我的机器cpu4个核心全部占用100%，同时8g的内存也是95%+，swap也占了一半多，虽说有一定好处，但是一定程度上妨碍了我学习和工作。考虑到学习工作问题以及想要提升一下编译速度，所以我在网友的推荐下，去Vultr租了一台高配置服务器专门用于编译（一个月500来不起，只能租）。 准备虽然是在服务器上，但是如果在自己的电脑上编译过程也是一样的。需要如下： 一台运行Ubuntu系统64位的PC（至少8个g的内存同时拥有100g以上的空闲硬盘空间） 一个好的网络 编译安装编译环境我们在电脑上写软件都需要搭建软件的开发环境，同理，编译系统也需要搭建环境，既然是编译源码，我们只需要安装编译需要的软件就行了。1$ sudo apt-get update &amp;&amp; sudo apt-get install git-core gnupg flex bison gperf libsdl1.2-dev libesd0-dev libwxgtk3.0-dev squashfs-tools build-essential zip curl libncurses5-dev zlib1g-dev openjdk-8-jre openjdk-8-jdk pngcrush schedtool libxml2 libxml2-utils xsltproc lzop libc6-dev schedtool g++-multilib lib32z1-dev lib32ncurses5-dev gcc-multilib maven tmux screen w3m ncftp liblz4-tool python 如果编译完成之后想要将包直接通过usb传到手机，可以安装一个adb包，然后通过adb push传到手机上，具体的使用以及安装方法自行google。 创建bin目录并且安装repo123$ mkdir -p ~/bin$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo 接下来将~/bin目录配置到PATH环境变量中。可以直接在终端使用以下代码配置环境变量，但是重开终端后会失效。1$ PATH=~/bin:$PATH 如果以后也要编译的话，我们可以将bin目录永久添加到环境变量中。使用编辑器编辑~/.profile文件，然后在其中添加以下代码。1234# set PATH so it includes user's private bin if it existsif [ -d "$HOME/bin" ] ; then PATH="$HOME/bin:$PATH"fi 然后运行source ~/.profile来使环境变量生效。 初始化LineageOS源码仓库设置的你Github用户名和邮箱12$ git config --global user.email "you@example.com"$ git config --global user.name "Your Name" 然后执行：12$ cd ~/LineageOS$ repo init -u https://github.com/LineageOS/android.git -b cm-14.1 同步源码到仓库直接执行以下代码：1$ repo sync -j4 其中-j4是使用四个线程同步源码的意思。然后执行：12$ . build/envsetup.sh$ breakfast "device name" 这里是同步机型的信息以及内核文件。 添加厂商vendorLineageOS官方的文档中使用的是一个脚本然后用adb从你的设备中提取vendor，我觉得这种方法太麻烦了，因为不一定是每一台设备都正好装了adb，比如说服务器上这种办法就不行了。于是，在另外一篇博客教程上我找到了替代的方法，现在应该都是这样做的了。github项目地址：https://github.com/TheMuppets仓库中有一个清单的项目，里面提供了所有的清单，你只需要将对应你机型的厂商vendor的代码添加到LineageOS/.repo/local_manifests/roomservice.xml文件中就行了。例如我的机型是Nexus6,设备代号shamu，对应的vendor是motorola，我往清单文件中添加的代码应该是如下这样的： &lt;project name=&quot;TheMuppets/proprietary_vendor_motorola&quot; path=&quot;vendor/motorola&quot; remote=&quot;github&quot; revision=&quot;cm-14.1&quot; /&gt; 其中的remote是原项目清单文件中没有的，要添加上，后面的是分支还是版本忘了，反正如果编译LineageOS14.1就填cm-14.1。添加完毕之后再次执行repo sync，此时就开始同步厂商vendor到你的LineageOS项目下了。 现在我们应该是准备好了，开始编译吧在编译之前我们要进行一些配置。 配置缓存123$ export USE_CCACHE=1$ ~/LineageOS/prebuilts/misc/linux-x86/ccache/ccache -M 50G$ export CCACHE_COMPRESS=1 上面的代码是设置编译过程中的缓存为50g，如果你第二次使用这台设备编译的话，你会发现编译的过程快了很多，其实是因为每一次源码更新都之更新了一部分，对于我们编译的旧版本来说，新版本有些地方压根就没有更改，所以我们的旧版本依旧可用。而编译生成的就存储在这个缓存中。这也就是为什么源码只有20g，编译完成之后就有100g左右的原因。 配置jack1$ export ANDROID_JACK_VM_ARGS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx8G" jack好像是jdk1.8的新特性，官方说要加上就加上。 开始编译配置完成，然后就开始编译吧。123$ source build/envsetup.sh$ croot$ brunch shamu 如果编译过程中出现问题，然后从新开始编译的话，请依次执行上面的语句，确保源码完整。不出意外的话，现在就应该开始编译了，然后你可以选择静静的等待。 编译完成编译完成之后只需要在命令行界面输入以下代码，就可以自动定位到生成的包的位置，当然，也可以手动cd到对应目录（~/LineageOS/out/target/product/&#39;设备型号&#39;/）。1cd $OUT 编译生成的文件名为lineage-‘日期’-14.1-‘设备代号’.zip以及对应的zip.md5sum，还有recovery.img。到此，教程结束。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ubuntu</tag>
        <tag>LineageOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Preference]]></title>
    <url>%2F2017%2F03%2F16%2F%E8%87%AA%E5%AE%9A%E4%B9%89Preference%2F</url>
    <content type="text"><![CDATA[说在前面前面的一篇博文中，我们讲到了Preference的一些坑，虽然不多，但是我会保持更新的。 这几天写Hitokoto的过程中也熟悉了甚至可以说基本掌握了Preference的基本使用，数据的存储以及默认值的设置，都已经没有问题了，但是再写“显示当前”的时候，需要弹出一个Dialog，有了之前EditTextPreference的坑之后，我没有尝试，我想应该也会报一个主题的问题，毕竟当时的错误是报在AlertDialog上的，所以我有直接写。 我查了一下Android的文档，发现官方中似乎有一个叫做DialogPreference的控件，但是这个类是一个抽象类，不能实例化，而之前提到的常用的Preference中，EditTextPreference就是一个继承了DialogPreference重写的Preference，所以说，如果我们需要一个单纯的Dialog的话，我们需要自定义并且继承DialogPreference。 提示对于自定义控件，我想我一直都写的不怎么好，虽然说在我自己的工具箱中写了三个自定义控件，但是功能都比较单一。所以这次自定义Preference也遇到了不少问题，当然，截至现在（2017年3月16日21:35:59），我依旧没有解决，虽然这个控件大部分完成了。 自定义Preference由于之前路由器的坑的原因，所以这次我直接选择官方的文档。 Android 框架包括各种 Preference 子类，您可以使用它们为各种不同类型的设置构建 UI。不过，您可能会发现自己需要的设置没有内置解决方案，例如，数字选取器或日期选取器。 在这种情况下，您将需要通过扩展 Preference 类或其他子类之一来创建自定义首选项。 扩展 Preference 类时，您需要执行以下几项重要操作： 指定在用户选择设置时显示的用户界面。 适时保存设置的值。 使用显示的当前（默认）值初始化 Preference。 在系统请求时提供默认值。 如果 Preference 提供自己的 UI（例如对话框），请保存并恢复状态以处理生命周期变更（例如，用户旋转屏幕）。 上面的是官方的说明，也正好给我们一个提示。 指定用户界面自定义控件的第一步都是指定布局文件，当然，如果是基于原有控件进行修改的不需要，我也没写过不指定布局的，对于绘图那一块我一直没有去详细的研究……在这里有四个默认构造函数，其中调用第一个和第四个的super方法需要sdk&gt;=21，我也不知道为什么，但是为了低版本能用，所以我调用的是第三个。在构造函数中我们需要指定我们的布局文件。通过以下代码：12345678public TextDialogPreference(Context context, AttributeSet attrs) &#123; super(context, attrs); setDialogLayoutResource(R.layout.mystery0_text_preference);//指定布局 setPositiveButtonText(R.string.mystery0_preference_content);//指定确认键文本 setNegativeButtonText(R.string.mystery0_preference_source);//指定取消键文本 setDialogIcon(null);//设置dialog图标 &#125; 对于布局中控件的绑定，我们需要重写View onCreateDialogView()以及void onBindDialogView(View view)方法。如下所示：123456789101112131415161718@Override protected View onCreateDialogView() &#123; super.onCreateDialogView(); if (view != null) return view; view = LayoutInflater.from(getContext()).inflate( R.layout.mystery0_text_preference, null); return view; &#125; @Override protected void onBindDialogView(View view) &#123; super.onBindDialogView(view); textView = (TextView) view.findViewById(R.id.mystery0_text_preference_view_content); sourceView = (TextView) view.findViewById(R.id.mystery0_text_preference_view_source); &#125; 保存设置的值在这里有几个方法，分别用于保存对应类型的值： persist*() 其中的*对应类型，如persistInt()对于这个方法的调用，一般是在Dialog关闭的时候保存数据。对于我们的这个例子，我想写的只是将数据在Dialog中显示，所以并不需要存储数据，所以在这里我没写。以下是Android的原文： 当 DialogPreference 关闭时，系统会调用 onDialogClosed() 方法。该方法包括一个布尔参数，用于指定用户结果是否为“肯定”；如果值为 true，则表示用户选择的是肯定按钮且您应该保存新值。 例如： @Override protected void onDialogClosed(boolean positiveResult) { // When the user selects &quot;OK&quot;, persist the new value if (positiveResult) { persistInt(mNewValue); } } 在此示例中，mNewValue 是一个类成员，可存放设置的当前值。调用 persistInt() 会将该值保存到 SharedPreferences 文件（自动使用在此 Preference 的 XML 文件中指定的键）。 初始化当前值系统将 Preference 添加到屏幕时，会调用 onSetInitialValue() 来通知您设置是否具有保留值。如果没有保留值，则此调用将为您提供默认值。onSetInitialValue()方法传递一个布尔值 (restorePersistedValue)，以指示是否已为该设置保留值。 如果值为 true，则应通过调用 Preference 类的一个 getPersisted\*() 方法（如整型值对应的 getPersistedInt()）来检索保留值。 通常，您会需要检索保留值，以便能够正确更新 UI 来反映之前保存的值。如果 restorePersistedValue 为 false，则应使用在第二个参数中传递的默认值。 代码如下：1234567891011@Override protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) &#123; if (restorePersistedValue) &#123; text = getPersistedString("test"); &#125; else &#123; text = (String) defaultValue; &#125; &#125; 注意：您不能使用 defaultValue 作为 getPersisted*()方法中的默认值，因为当 restorePersistedValue 为 true 时，其值始终为 null。提供默认值如果 Preference 类的实例指定一个默认值（使用 android:defaultValue 属性），则在实例化对象以检索该值时，系统会调用 onGetDefaultValue()。您必须实现此方法，系统才能将默认值保存在 SharedPreferences 中。 12345@Override protected Object onGetDefaultValue(TypedArray a, int index) &#123; return a.getString(index); &#125; 方法参数可提供您所需的一切：属性的数组和 android:defaultValue（必须检索的值）的索引位置。 之所以必须实现此方法以从该属性中提取默认值，是因为您必须为此属性指定在未定义属性值时所要使用的局部默认值。 显示官方文档中还有保存首选项设置的代码重写，但是由于我这里用不到，所以没有去研究。所以我直接重写了显示方法，也就是void showDialog(Bundle state)，在之前，无论我实在那个函数中调用settext方法都会得到一个空指针的Exception，不得已，我只能将settext方法写在显示的方法中。如下：1234567@Override protected void showDialog(Bundle state) &#123; super.showDialog(state); textView.setText(text); sourceView.setText(source); &#125; 保存，调试，成功。效果图： 后话但是很快我便发现了一个异常，虽然显示的结果完全正常，但是在第二次点击的时候就报错。以下是错误原文：1234567891011121314151617181920212223242526java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first. at android.view.ViewGroup.addViewInner(ViewGroup.java:4417) at android.view.ViewGroup.addView(ViewGroup.java:4258) at android.view.ViewGroup.addView(ViewGroup.java:4230) at com.android.internal.app.AlertController.setupCustomContent(AlertController.java:601) at com.android.internal.app.AlertController.setupView(AlertController.java:495) at com.android.internal.app.AlertController.installContent(AlertController.java:253) at android.app.AlertDialog.onCreate(AlertDialog.java:423) at android.app.Dialog.dispatchOnCreate(Dialog.java:395) at android.app.Dialog.show(Dialog.java:294) at android.preference.DialogPreference.showDialog(DialogPreference.java:297) at com.mystery0.tools.TextDialogPreference.TextDialogPreference.showDialog(TextDialogPreference.java:93) at android.preference.DialogPreference.onClick(DialogPreference.java:277) at android.preference.Preference.performClick(Preference.java:994) at android.preference.PreferenceScreen.onItemClick(PreferenceScreen.java:249) at android.widget.AdapterView.performItemClick(AdapterView.java:310) at android.widget.AbsListView.performItemClick(AbsListView.java:1156) at android.widget.AbsListView$PerformClick.run(AbsListView.java:3128) at android.widget.AbsListView$3.run(AbsListView.java:4043) at android.os.Handler.handleCallback(Handler.java:751) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:154) at android.app.ActivityThread.main(ActivityThread.java:6126) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:886) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:776) 我想我应该遇到这个错误很多次了，当时在学习Fragment的时候并没有认真去学，导致后来写fragment的时候非常依赖ide，同时fragment的相关错误我都不知道如何解决，而这个就是错误中的一种。我想我会解决这个问题的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Preference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Preference简单使用]]></title>
    <url>%2F2017%2F03%2F12%2FPreference%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[说在前面这几天呢在写Android的桌面小部件，其实去年的时候我就和别人一起研究过小部件的使用。当时在写小部件的配置的时候使用的是activity的界面，所以只需要解决的是小部件默认设置的加载即可。这一次写的时候突然发现了一个东西，在Android Studio的默认app模板中有一个settingsActivity，其实是一直都有的，曾经新建的时候好奇，建了一个，但是没有找到layout，代码也看不懂是写的什么。这一次呢就去搜索了一下preference，发现这是Android的设置样式，也就是说正规的app的设置界面应该是使用这个来写，想到之前写的app都是用的一个activity来提供设置，瞬间觉得有点懵逼0.0。 关于设置下面这一段话是Android API中关于设置的介绍： 应用通常包括允许用户修改应用特性和行为的设置。例如，有些应用允许用户指定是否启用通知，或指定应用与云端同步数据的频率。 若要为应用提供设置，您应该使用 Android 的 Preference API 构建一个与其他 Android 应用中的用户体验一致的界面（包括系统设置）。本文旨在介绍如何使用 Preference API 构建应用设置。 曾经我一直以为Android的设置一样是用Activity来写的，看来我还是too young～接原文： 设置是使用您在 XML 文件中声明的 Preference 类的各种子类构建而成，而不是使用 View 对象构建用户界面。 Preference 对象是单个设置的构建基块。每个 Preference 均作为项目显示在列表中，并提供适当的 UI 供用户修改设置。例如，CheckBoxPreference 可创建一个列表项用于显示复选框，ListPreference 可创建一个项目用于打开包含选择列表的对话框。 您添加的每个 Preference 都有一个相应的键值对，可供系统用来将设置保存在应用设置的默认 SharedPreferences 文件中。当用户更改设置时，系统会为您更新 SharedPreferences 文件中的相应值。您只应在需要读取值以根据用户设置确定应用的行为时，才与关联的 SharedPreferences 文件直接交互。 为每个设置保存在 SharedPreferences 中的值可能是以下数据类型之一： 1. 布尔值 2. 浮点型 3. 整型 4. 长整型 5. 字符串 6. 字符串 Set 由于应用的设置 UI 是使用 Preference 对象（而非 View 对象）构建而成，因此您需要使用专门的 Activity 或 Fragment 子类显示列表设置： 如果应用支持早于 3.0（API 级别 10 及更低级别）的 Android 版本，则您必须将 Activity 构建为 PreferenceActivity 类的扩展。 对于 Android 3.0 及更高版本，您应改用传统 Activity，以托管可显示应用设置的 PreferenceFragment。但是，如果您拥有多组设置，则还可以使用 PreferenceActivity 为大屏幕创建双窗格布局。 创建首选项 Activity 和使用首选项片段部分将讨论如何设置 PreferenceActivity 以及 PreferenceFragment 实例。 对于这篇文章，我并不是一个preference老手，所以不写基本用法之类的。在这里我提供几个链接，是别人写的使用方法： Android的设置界面及Preference使用 在研究preference的这几天，也出现了一些问题，比如说控件的监听问题以及获取实例之类的。以下是一些我出现的问题： 问题一 关于界面的问题最开始的时候我就使用了一个模板，然后仿照着模板往我自己的App中加代码。出现的第一个问题就是级数问题（不清楚如何表达）：设置界面肯定会有这每一种情况，点击某一个设置项，跳转到具体的设置，也就是说根所在的布局只是提供一个入口以及将设置项分类的功能，对于这一个功能，preference只需要在根的文件中使用header标签即可，至于xml中几个标签的使用，网上有很多教程。 问题二 在设置项中使用TextInputLayout提示主题问题由于以前写过小部件，所以我要做的基本上是将以前写的代码转换过来并且优化一下就可以了。但是以前在设置中写了一个设置小部件刷新时间的设置项，具体效果是点击则弹出一个edittext，使用material design之后弹出的自然是使用的TextInputLayout，但是在运行的时候出现了问题，我想大多数人在看preference的使用方法的时候一定不像我一样这么敷衍，当时我只是简单看了一下就开始使用了，所以才出现这一个问题。具体原因是TextInputLayout是design库中的东西，使用这一个东西的时候，需要将Activity的theme设置Appcompat主题，由于preference本身是一个fragment，所以出现了玄学问题。我一度认为是主题的原因，但是无论我怎么改依旧是报错，卡在这里两天。就像之前我提到SnackBar没有动画的问题一样，尝试了英文搜索，好几个问题描述和我都不相同，我将我的这个错误归纳为Activity使用的Appcompat主题，但是在fragment中使用design库出现了主题问题。第二天，我依旧尝试解决这个问题，也许是运气好吧，有一个问题中有回答指向了Android API界面，关于PreferenceActivity的页面（自备梯子）。对于英语的东西，我能够看懂的并不多，至少我运气不错，看懂了下面的句子（好渣的英语水平0.0）： Developer Guides For information about using PreferenceActivity, read the [Settings](https://developer.android.com/guide/topics/ui/settings.html &quot;Settings&quot;) guide. 链接跳转到设置的页面，简单翻阅了一下我才知道preference中提供了几个首选项：常用的Preference，CheckBoxPreference，ListPreference，EditTextPreference。当初只注意到前三个，如果新建过模板的应该会知道，前三个在模板中都有使用，至于最后一个应该没有使用，不然我应该会知道的。至于解决方法，自然是将这个设置项修改为EditTextPreference，自然就解决了输入问题。简单配置了一下hint，我发现其中包含的EditText应该是普通的EditText，并不是Material Design库中的新控件。 感谢列表Android API Android的设置界面及Preference使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Preference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android7.0+修改导航栏图标方法]]></title>
    <url>%2F2017%2F03%2F02%2FAndroid7.0%2B%E4%BF%AE%E6%94%B9%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%9B%BE%E6%A0%87%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[重要事件（3/16更新）虽然不知道是什么原因，但是这两天我在着自己的mod包的时候，依旧是反编译回编译SystemUI，但是这一次却无法开机，导致我的系统数据出现异常，然后就只能三清然后重新刷，我怀疑是签名的问题，正好这两天写完了一个app在打包发布的时候发现了这样一个细节： 点击右边的链接，跳转的是链接（自备梯子）。这个页面是Android 7.0引入的应用签名方案，据说能够对apk提供更多的保护，所以我怀疑是因为这个原因。但是我还是不清楚为什么别人能改，所以在这里告诫大家一下，刷机需谨慎，记得做好备份，数据是无价的。 以下是原文 说在前面对于Android手机上的导航栏，虽然说Android7.1.1上我是用的Pixel的导航栏，但是用了这么久了，难免有些审美疲劳，然后手就痒了，打算自定义样式。这个方法其实一直都能用，但是在6.0我们可以用CMTE来修改系统的主题，从而修改导航栏图标，甚至是系统的图标之类的，奈何年前Cyanogen挂掉了（原文链接：Cyanogen services shutting down），原来的CyanogenMod的人重新弄了一个系统，也就是LineageOS，但是不知道什么原因，迟迟没有加入主题引擎，我们也只有等待。前几天XDA上突然传出LineageOS14.1将不会使用CMTE，这也算意味着CMTE随着CM的dead而死去（原文链接：EXCLUSIVE: CyanogenMod Theme Engine Isn’t Coming Back, LineageOS to Find Replacement）。但是幸好的是LineageOS会寻找新的主题引擎，目前看来最有可能的应该就是Substratum。但是目前这段过渡期比较难熬，就像Android7.0去年下半年出来，但是7.0的框架迟迟未出，虽然知道很大一部分原因是因为作者的时间并不只是Xposed，但是这么长的时间过去了……于是，手开始痒了。本来是在酷安下载了一个图标包（Sorcery 图标，链接），因为听别人说这个图标包的作者适配了Pixel Launcher，所以下载看看，大概原理是安装一个图标包，但是并不是一般的图标包，可以理解为将原图标包修改之后替换的。安装成功，图标也覆盖上去了，但是这种办法只能在桌面有作用，我看了最近任务栏依旧是原图标，但是这也够了。安装成功之后，覆盖率还是挺高的，只是我觉得个别图标不太好看，本来相联系开发者修改的，但是又一想，作者适配了，况且并不是用主题来安装的，太多要求并不好。于是解包修改不喜欢的图标，幸运的是软件本身并没有混淆，加密之类的。修改的过程中就想起了我以前做的一个CM13的主题（Github链接），那个是我将别人的比较好看的素材整合了一下自己使用的，于是就去找我以前使用的图标。找到了原来的图标，还顺便看到了以前CMTE的主题修改导航栏图标的路径，突然间我就想到了或许可以解包SystemUI.apk来修改导航栏图标。我在手机上进入那个目录，确实看到了导航栏的图标。然后就开始了我的修改。 教程准备要修改SystemUI.apk，自然需要的是原SystemUI.apk，我想root权限应该是必须要的。当然，在recovery模式下弄出SystemUI.apk应该也行，没具体试过，TWRP下是可以的。一台具有root权限的手机一台能用的电脑（提前装上apktool以及文本编辑器） 教程开始首先将手机上/system/framework目录下的apk文件导入apktoolapktool install-framework xxx.apk 使用apktool d SystemUI.apk命令解包SystemUI.apk 打开解包之后的文件夹，定位到SystemUI\res\drawable-xxxhdpi-v4\目录下，这个时候我想你已经看到了导航栏的虚拟键图标了 将你修改过的图标替换到原文件在SystemUI文件夹上一级目录打开cmd，执行以下命令apktool b SystemUI 注：重新编译之后的文件目录在SystemUI\dist下，注意，此时这个回编译的apk并没有签名，打开源文件SystemUI.apk，然后将除了META-INF文件夹外的其他文件和文件夹删掉。然后将回编译的apk里面的文件拉到源文件中。这个时候可以替换了，但是为了安全，我们把源文件备份一下，然后写一个简易的刷机包。 下载刷机包模板（链接：Google Drive，OneDrive）解压如果有兴趣的可以修改脚本代码，大概的我已经写好了将回编译之后的SystemUI.apk放到以下目录TemplateMod\system\priv-app\SystemUI（注意新建目录，和脚本中对应） 关于刷机包签名与否的问题我也不太清楚，我知道的是TWRP刷机不用验证签名，所以就直接压缩zip即可在TWRP中选择刷入说在后面当然，这种办法无论是那个版本都是能够使用的，只是不同的版本或者不同的系统，路径会不同（国内的厂商定制版本文件或许加密了）。除了定制导航栏图标，SystemUI还有其他的文件，比如状态栏的图标，文本之类的。除了这个，还可以反编译Settings进行一些修改，记得刷机之前要备份原文件只是突然间就无聊了，过下手瘾~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView搭配Material Design新控件使用]]></title>
    <url>%2F2017%2F02%2F25%2FWebView%E6%90%AD%E9%85%8DMaterial%20Design%E6%96%B0%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[说在前面这两天在帮同学的网站写客户端，要求的功能是点击菜单中的某一项显示一个网页，之前的一个客户端是直接调用Intent跳转默认浏览器来进行访问。这次想做成在应用中访问的，也就是使用WebView来显示，虽然学了安卓快一年了，却从来没有写过WebView，过程中遇到了一些问题，故此记录。 效果展示 正如gif所示，WebView往下滑隐藏Toolbar，往上滑显示Toolbar，往左滑后退，往右滑前进。 WebView下滑隐藏ToolBar，上滑显示ToolBar使用了Matarial Disign的小伙伴应该很清楚，Google提供了CoordinatorLayout来使控件能够响应滚动事件，比如说当滚动RecyclerView的时候，只需要几行代码就能够让ToolBar跟随着滚动，并且非常流畅，所以我打算的就是通过CoordinatorLayout来实现这个效果。我google了一些博客，有些人是通过重写WebView的onScrollChanged方法来实现，这样的话虽然可以进行很强的自定义，但是我觉得却太复杂了，对于我的这个应用来说，需要实现的功能很简单，不用这么复杂。 导包我想各位应该都清楚的，所以我就不说版本了布局代码如下1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:context="com.weily.mutour.activity.WebActivity"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/app_bar" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:layout_scrollFlags="scroll|enterAlways" app:popupTheme="@style/AppTheme.PopupOverlay"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout="@layout/content_web"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这个代码各位应该非常眼熟，如果用的是Android Studio，同时新建Activity的时候选择Basic Activity，会自动新建activity_xxx.xml以及content_xxx.xml，而这就是activity的那个文件的源码，注意源码中相比较于默认的源码，我在ToolBar的标签那里添加了一个app:layoutscrollFlags属性。各位如果清楚CoordinatorLayout的应该都知道是什么意思，所以在这里我就不多说了，如果不懂的话可以参考这篇博客。接下来是content的源码：1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" tools:context="com.weily.mutour.activity.WebActivity" tools:showIn="@layout/activity_web"&gt; &lt;WebView android:id="@+id/web" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; 前几天我在研究为什么SnackBar没有动画效果的时候（具体可参考我的上一篇博客），也顺便纠结了一下为什么我写的登陆界面不能在弹出键盘的时候自动伸缩，没有特意去找原因，猜测应该是布局中的控件的原因，同样的属性，同样的父布局，但是子布局中有RecyclerView的时候就能够自动伸缩，登陆界面没有RecyclerView，同时也没有其他的可伸缩的布局（比如NestedScrollView，ListView等），或许是因为这个原因。这个方法的来源是这篇博客：Toolbar在WebView滚动下的显示和隐藏的实现而这篇博客中的代码将WebView放在了LinearLayout中，LinearLayout的父布局是v4包中AppBarLayout，如果在IDE中直接添加这个控件不会报错，但是会报一个警告。 看起来是因为这个控件的原因，博客的评论中也提到这个包找不到。同时评论中有人提到将AppBarLayout换成NestedScrollView就行了，然后删掉LinearLayout。当然，这也是我的处理办法。写完之后就能够在滑动WebView的时候实现ToolBar下滑隐藏，上滑显示的效果了。 WebView右滑后退，左滑前进本来上面的代码就能够满足要求了，但是我在调试的时候发现一个问题，由于我调试嵌套的并不是一个单独的网页，网页中还有其他的链接，点击也能够正常跳转，但是却存在无法后退的问题，或许是没有找到。为了解决这个问题，我首先想到的方法是使用手势。经常我们在使用一些常用app的时候，能够通过手势执行一些快速操作，比如说Telegram在聊天界面往右滑会有一个动画效果，同时界面回到聊天列表。所以说手势的使用还是挺普遍的。 监听WebView触摸事件看到这个标题，我想一定能很快写出监听的代码12345678910111213141516171819202122232425@Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: start = event.getX(); break; case MotionEvent.ACTION_UP: float end = event.getX(); float distance = end - start; if (distance &gt; 400) &#123; webView.goBack(); break; &#125; if (distance &lt; -400) &#123; webView.goForward(); break; &#125; break; &#125; return super.onTouchEvent(event); &#125; 完全正确的代码，但我调试的时候却发现了问题，无论我怎么滑动都没有反应，然后我使用log发现这个方法根本没有执行，所以无效。google了一下原因，得到这么一个答案： 一般我们用于接收GestureDetector对象的方法是OnTouchevent();,而在View组件占用了屏幕空间之后，这个方法就无效了，只有换成 dispatchTouchEvent方法才有效！ 原文链接：Webview中无法触发手势方法（ontouchevent,onfling…)的解决方法于是将onTouchEvent换成dispatchTouchEvent，完美解决。 说在后面这两天我算是真正体会到了Google的强大，比如说上一篇博客中的SnackBar没有动画，我使用google直接搜索“SnackBar 无动画”，并没有什么有价值的文章，甚至完全没有一个像我一样的问题，然后试着使用英语搜索“snackbar no animation”，才找到大量的解决方法。至于百度嘛，我用中文还是英语，搜索出来的结果并没有什么区别，当然，也和我用中文google差不多的样子。 参考列表如何监听webview的滚动事件Android WebView的前进、后退、与刷新Webview中无法触发手势方法（ontouchevent,onfling…)的解决方法 Toolbar在WebView滚动下的显示和隐藏的实现可折叠的Toolbar—CollapsingToolbarLayout]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WebView</tag>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决SnackBar无动画现象]]></title>
    <url>%2F2017%2F02%2F24%2F%E8%A7%A3%E5%86%B3SnackBar%E6%97%A0%E5%8A%A8%E7%94%BB%E7%8E%B0%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[发现问题突然间不知道从什么时候开始，手机上的app只要是调用了SnackBar的地方，SnackBar显示都没有效果，这两天突然开始察觉到这个问题了，开始各种google，但是都没有找到直接让SnackBar没有动画的结果（中文），甚至我还以为是SnackBar的源码改了。但是又觉得不对，google的这个SnackBar新控件非常不错，不应该把动画去掉啊。为此，我特意将design包的版本回退到22.2.0版本，依旧是没有动画。这里开始我就觉得不对了，google不可能去掉并且旧版本依旧没有动画，那么应该是我的配置上的问题。想到这里，我开始去查看CoordinatorLayout的用法，但是依旧没有任何卵用。 解决问题突然间我想到了一个问题，会不会是国内还没有察觉到这个问题，但是国外有了呢，我是不相信全世界就我一个人有这个问题的。抱着试一试的态度，我开始google snackbar no animation，果不其然，找到了许多和我相同的问题。 简单的查看了一下，有的人说是开发者选项中的动画缩放（？）的问题，但是我试了依旧错误，继续看才看到一个回答是辅助功能导致的。 查看我手机上的辅助功能选项，发现打开了一个服务——冰箱的后台服务。 将这个服务关闭之后，再次打开应用，SnackBar的动画显示出来了。 说在后面继续查看了这个问题，但是没有看出什么来，只是提供了一个方法，使用AccessibilityManager.isEnabled()来判断辅助功能是否开启，但是我在代码中添加提示错误，AccessibilityManager是一个final类，这个类中使用了单例模式，一个static方法返回实例，但是我在调用这个静态方法的时候报错，提示找不到这个方法，查看源码AccessibilityManager类是公有的，静态方法也是公有的，但是报错，不知道为什么，如果有人知道为什么的请告诉我。 2017年8月3日更新：时间过去了五个月，今天我总算是找到了解决方法。前面我们已经说了SnackBar没有动画是因为开启了无障碍服务，在SnackBar的父类BaseTransientBottomBar中会检测无障碍服务的开启状况，偏偏SnackBar是final类，看起来似乎有点无解，继承SnackBar重写是肯定不行的。幸运的是，我在StackOverFlow上找到一个解决方法，参考链接。这个方法是利用反射将AccessibilityManager类在app中调用的对象的mIsEnabled属性值改为false，这样就能通过BaseTransientBottomBar的检测，同时系统的无障碍服务并没有关闭，也不影响使用。 为了方便使用，我将这一段代码添加到了我自己的库中，这样我只需要直接在Application中初始化这样一句话就能够实现无视无障碍服务开启状况显示SnackBar的动画。以下是我的代码： 123456789101112131415161718192021222324252627object ASnackBar&#123; private val TAG = "ASnackBar" @JvmStatic fun disableAccessibility(context: Context) &#123; val contextThemeWrapper = ContextThemeWrapper(context, R.style.Theme_AppCompat) val view = LayoutInflater.from(contextThemeWrapper).inflate(R.layout.mystery0_snack_bar_coordinator_layout, null) Snackbar.make(view, "SnackBar", Snackbar.LENGTH_SHORT) .apply &#123; try &#123; val mAccessibilityManagerField = BaseTransientBottomBar::class.java.getDeclaredField("mAccessibilityManager") mAccessibilityManagerField.isAccessible = true val accessibilityManager = mAccessibilityManagerField.get(this) val mIsEnabledField = AccessibilityManager::class.java.getDeclaredField("mIsEnabled") mIsEnabledField.isAccessible = true mIsEnabledField.setBoolean(accessibilityManager, false) mAccessibilityManagerField.set(this, accessibilityManager) &#125; catch (e: Exception) &#123; Logs.e(TAG, "disableAccessibility: $e") &#125; &#125; &#125;&#125; 使用时只需要这样的一行代码即可搞定，当然，前提你需要使用我的这个ToolsDemo库。1ASnackBar.disableAccessibility(this); 参考列表java - SnackBar appear animation - Stack OverflowIssue 206416: Snackbar no longer slides onto screenSnackbar and other animations stopped working on some Android devices]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐讯K2 A6版 V22.4.6.3 路由器刷机踩坑]]></title>
    <url>%2F2017%2F02%2F18%2F%E6%96%90%E8%AE%AFK2%20A6%E7%89%88%20V22.4.6.3%20%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E6%9C%BA%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[说在前面前段时间从京东上撸了一个K2，正好是0元购的活动，所以就弄了一个，今天下午就开始折腾路由器。京东链接从第一个教程中我知道为什么这么多买这个路由器的人要刷机了，据说原因是因为官方固件存在后门，会自动将用户的浏览记录上传，所以推荐用户将斐讯路由器刷成其他的第三方固件。（具体链接） 错误的认为由于从来没有玩过这个，所以我一直以为路由器刷机应该不难，然而事实是确实不难，只是需要找对教程。我找的第一个教程（链接）是2016年4月份，也是从这个教程我知道了官方固件的问题，更加坚定了我刷机的决心。但是技术的更新换代也实在是太快了，由于这篇教程没有写明适用的版本，所以我错误的认为了这个是通用的教程（大错特错）。所以第一步开启telnet就得到了错误：非法的配置文件。然后我才意识到版本的更新以及厂商的封堵。 寻找正确的教程意识到犯的错误之后，我开始关注路由器的版本以及教程的适用版本以及帖子发布时间。不负众望，我找到了一个很新的帖子（由于我的路由器固件版本是22.4.6.3，所以我关注的都是22.4.6.3的帖子），新到发布时间是今天的凌晨（不敢相信，后来我才知道这是转载的，原帖发布时间是：2016-12-20）。由于新帖踩得坑并不多，所以我在这里贴上原帖地址：斐讯K2 22.4.6.3 非telnet 页面直刷 Breed 详细方法（图文）强烈推荐帖子中的一个用户的视频操作：（swf文件，可直接用chrome打开）原链接http://pan.baidu.com/s/1dE8p0g5 密码：cptx如果和我一样不喜欢百度云的可以通过我提供的onedrive链接以及google drive链接下载观看。 教程开始由于我也没试过其他的教程，甚至不知道是否还有其他的教程，所以我能够分享的只有这么一个教程，我会在教程中强调一下容易操作错误的点。 前提条件 安装有Firefox，傲游，Chrome等，能进行页面编辑的浏览器的电脑， 用网线将电脑与K2的Lan口连接， 保持K2与Internet互联网连通，PPPOE或者级联上级路由器均可。 注意点一：第三点所说的与互联网畅通是要求你的路由器能够正常访问网络，并且不存在受限的状况，如果你是用的是Windows10的笔记本，将wifi关闭，通过网线连接路由器，如果网络标志没有提示受限就可以了。切记：如果受限，则教程不会成功。 正式教程在地址栏内输入K2登录地址，登录K2管理界面，选择右上角的“定时重启路由器”。 点选时间中的右侧下拉分钟选择框，通过浏览器的审查元素查看选择器的源码。 将“05”修改成为“05 | wget http://breed.hackpascal.net/breed-mt7620-phicomm-psg1208.bin” 之后，鼠标移动到黑框外的空白处点击鼠标左键，结束编辑。 在定时重启路由器页面上选择05之后，点击“保存”。 注意点二：此处操作。请多选择05选项几次，确保无错。这是通过命令将配置文件下载到路由器内部，如果网络暂时刷新时间较长，则说明这一步成功了，因为路由器正在下载文件。如果没有感觉到有什么变化，也请继续操作试试，或许是很快就下载好了。 重复以上的替换操作，执行以下操作将“05”修改成“05 | mtd unlock Bootloader” 将“05”修改成“05 | mtd -r write breed-mt7620-phicomm-psg1208.bin Bootloader“ 注意点三：第三条命令执行完毕之后，路由器会自动重启，原教程说的是路由器的指示灯会变红，但是我的依旧是蓝色的，所以，这里应该注意的是电脑上的网络标志，因为我的电脑显示网络连接断开，过了一会之后路由器指示灯也变红了，此时电脑通过网线连接上了路由器，个人觉得此时路由器应该还在启动，所以等个几分钟，等到路由器的指示灯变成蓝色之后就能够执行下一步操作了。 拔除K2上Wan口的网线，路由器断电，持续按住路由器上的reset按钮，接通路由器电源，几秒后松开reset按钮。（具体几秒自己感知吧。。。十秒肯定是够了吧）在浏览器地址栏输入“http://192.168.1.1” 访问Breed Web。进入Breed Web后，请及时进行EEPROM备份，然后再刷其他的固件。说明一点第三方固件有很多其他的功能，比如说自动连接ss之类的，而且也能够通过ssh连接到路由器。 最后教程到上面就已经完了，至于为什么图片采用的是原教程的图片，主要是现在我的路由器已经刷成了第三方固件，同时我也不知道怎么恢复官方固件，所以没有办法截图。第一次玩路由器，以后会分享一些玩路由器时踩的坑之类的。此教程应该是适用斐讯路由器中有自动重启路由器操作的固件版本。本人所用版本：斐讯K2 A6 22.4.6.3 相关链接斐讯K2 22.4.6.3 非telnet 页面直刷 Breed 详细方法（图文）斐讯K2路由刷openwrt实践教程（不适用本版本）免费的总是最贵的,斐讯K1官方固件惊现后门——疑似窃取用户隐私]]></content>
      <categories>
        <category>Linux 路由器</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu使用Shadowsocks-qt5科学上网]]></title>
    <url>%2F2017%2F01%2F12%2FUbuntu%E4%BD%BF%E7%94%A8Shadowsocks-qt5%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[由于大多数朋友都问我在Ubuntu上面怎么科学上网，为了防止以后忘记，故此记录。 本教程使用的配置Ubuntu 16.10Shadowsocks-qt5一个可用的ss账号一根能够通向www的网线 说明shadowsocks-qt5是ubuntu上一个可视化的版本，当然也有脚本的那种，但是没有使用过。 操作流程安装shadowsocks-qt5sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5 第一行代码是添加软件的ppa源，当然，这是作者提供的然后执行update更新并安装shadowsocks-qt5。如果安装成功之后，按win键搜索应该能够找到软件，如下图所示： 配置shadowsocks-qt5打开软件，如下图所示：单击Connection添加服务器配置，在你想要默认使用的配置里勾选自动启动。配置完成之后应该是下图的这个样子： 配置系统代理单独是配置shadowsocks-qt5并不能使用网络，所以还要配置系统的代理。打开设置-网络-网络代理代理方式选择手动，第一个http代理清空配置，端口设置为0，然后第四个socks代理设置为127.0.0.1，端口填写1080，ip和端口在shadowsocks-qt5中有设置，使用默认的就好。 配置浏览器（Chrome）应该来说现在能上网了，但是对于浏览器来说，我们可以添加插件用来自动判断当前网址是否需要科学上网。我在这里使用的是chrome，所以使用chrome的方法来写教程。 下载chrome浏览器如果你已经有了可以跳过此步，直接查看下一步。官网下载chrome如果因为其他的什么原因，可以通过我提供的地址下载Chrome。 下载代理插件Proxy SwitchyOmegachrome扩展商店的地址在这里。同样提供另外的地址。 注意因为上面的链接是onedrive的链接，如果仍然无法访问可以访问这个（百度网盘在linux没有客户端，可以满速下载）。 安装好Proxy SwitchyOmega之后浏览器会自动打开配置界面，如下图所示：新建一个规则，名字随意，然后代理规则那里选择socks5，服务器地址填127.0.0.1，端口1080，如下图所示：也可通过备份文件导入配置。然后保存修改，在浏览器中选择auto switch（自动切换）或者GFWed（备份文件恢复的配置，即自己添加的配置规则）。自动切换可以根据不同的网址来自动选择是否使用代理，我嫌麻烦就使用的全局。现在在浏览器中应该能够流畅的科学上网了，当然，取决于你自己的shadowsocks账号配置。 添加shadowsocks-qt5自动启动使用一段时间后你应该会发现每次开机都要手动运行shadowsocks-qt5，所以我们还要添加shadwsocks-qt5的自动启动。Ctrl+Alt+T打开终端，输入下面的指令： gnome-session-properties然后弹出这样的窗口：点击右边的add，然后选择/usr/bin/ss-qt5，名称随便输，保存即可。教程结束。 感谢列表Ubuntu下shadowsocks科学上网姿势 ubuntu 使用图形化配置 shadowsocks -qt5 开机自动启动（配置开机启动） gfwlist 谷歌浏览器Chrome+ShadowSocks+Proxy SwitchyOmega自动翻墻教程]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Shadowsocks</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人服务器搭建Hexo博客（Windows篇）]]></title>
    <url>%2F2017%2F01%2F11%2F%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%EF%BC%88Windows%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说在前面由于我也是第一次搭建，所有如果有什么地方说的不对，请大家提出来。很早之前就想从WordPress换到Hexo，倒不是说WordPress不好，只是不知道为什么我的后台页面是英语，一脸懵逼，也没去管，正好看到朋友自己搭建的挂载github上的博客非常好看，所以想搭一个Hexo看看。于是有了这篇教程。 Hexo原理经过这一天的折腾，大改理解了Hexo的原理。首先我们写的博客源文件是md文件，然后经过Hexo的解析，生成html文件和文件目录，然后直接访问这些html文件就能浏览到对应的文章。至于将html文件推到github或者个人服务器上，就是作者自己的事情了。 此文使用配置Windows10 PC ×1Ubuntu16.04 主机 ×1 流程1.windows安装git去git官网下载git安装包，然后安装。 git环境配置：按照大多数教程的方法，说的是系统变量Path新增值为git安装目录下的bin文件，我是很早之前用github的时候就安装并配置了git，去找了一下我的path，只找到值为git安装目录下的cmd文件，但是在cmd中空打git有命令，说明能使用，所以各位还是先试试bin文件夹吧，若不行请试一下cmd文件夹。配置成功后在cmd窗口中直接输入git应该会出现帮助菜单，如下图所示： 生成ssh密钥1.打开C:\Users\&lt;用户名&gt;\.ssh文件夹，如果没有就新建2.在空白处单击右键，选择Git Bash Here打开终端3.设置git用户名 git config --global user.email &quot;email@example.com&quot; git config --global user.name &quot;username&quot; 4.生成ssh密钥 ssh-keygen -t rsa -C &quot;email@example.com&quot; 一路回车生成公钥和密钥，一会要用到公钥id_rsa.pub 2.安装Node.js在Node.js官网下载最新版，一路默认安装。 3.安装Hexo到本地在任意位置创建一个文件夹，用于存放Hexo，在这里我是放在E:\Hexo文件夹，下文以此代替。 安装Hexowin+r打开cmd，cd到创建的Hexo文件夹，输入node后执行如下命令： npm install -g hexo-cli hexo init npm install hexo d -fg hexo serve 第一句是通过npm安装hexo，第二句是初始化hexo到当前目录（即E:\Hexo文件夹）。执行完最后一句之后，静态网页已经能够在http://localhost:4000中访问了，当然，只是本地。这个时候查看hexo的目录可以看到下图的结构：其中themes便是主题文件夹，里面存放的是主题，通过_config.yml文件设置主题以及网站的信息。 4.vps的配置我在这里使用的ubuntu的主机，通过Putty连接远程主机，进入命令行界面。 1.安装git$ sudo apt-get install git-core 2.安装nginx：$ sudo apt-get install nginx 3.新建git用户切换到root用户，然后执行以下语句： adduser git chmod 740 /etc/sudoers vim /etc/sudoers 在编辑器中找到如下内容： # User privilege specification root ALL=(ALL:ALL) ALL 在后面添加一行： git ALL=(ALL) ALL 保存并退出后执行： chmod 440 /etc/sudoers 4.创建git仓库，配置ssh登陆su git cd ~ mkdir .ssh &amp;&amp; cd .ssh touch authorized_keys vi authorized_keys cd ~ mkdir hexo.git &amp;&amp; cd hexo.git git init --bare 在vi authorized_keys时，将之前在windows上用git生成的key粘贴进去，注意是全文粘贴！测试一下，返回到windows，在任意目录右键git bash here，输入ssh git@vps的ip地址，如果能够远程登录的话，则表示设置成功。 5.设置网站目录并赋予git用户访问权限nginx默认打开的目录是/var/www/html，所以我们要让git用户能够访问到这个目录并进行修改。当然也可以新建一个目录用于存储hexo的文件，之后只要在nginx的配置文件中修改服务器入口即可。我在这里是新建了一个目录存放hexo文件，所以执行如下命令： cd /var/www mkdir hexo chown git:git -R /var/www/hexo 6.配置git hookssu git cd /home/git/hexo.git/hooks vim post-receive 输入如下内容后保存并退出： #!/bin/bash rm -rf /tmp/hexo git clone /home/git/hexo.git /tmp/hexo rm -rf /var/www/hexo/* cp -rf /tmp/hexo/* /var/www/hexo 这一段脚本学过shell的人应该都能看懂。然后赋予脚本权限（切换到root用户） chmod +x post-receive 接下来赋予git用户访问这三个目录的权限，/var/www/hexo已经赋予了，还有其他的两个目录： chown git:git -R /home/git/hexo.git chown git:git -R /tmp/hexo 7.配置nginxroot用户下执行： vim /etc/nginx/sites-available/default 找到root /var/www/html;将其修改为： root /var/www/hexo; 保存并退出。重启nginx service nginx restart 8.配置Hexo使用文本编辑器打开hexo文件夹下的_config.yml，修改deploy选项 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git message: update repo: git@vps的ip地址:hexo.git,master 然后在hexo文件夹新建一个bat脚本文件，命令是 hexo g &amp;&amp; hexo d 当然也可以不建立，各人所好吧。双击运行，推送成功之后，直接打开vps的ip地址应该就能直接访问hello world了，至此，教程结束。 更新博客的方法新建md文件（后缀名是.md），拷贝到hexo文件夹的source\_posts中，双击运行脚本（或者打开cmd cd到hexo文件夹，执行命令hexo g &amp;&amp; hexo d）。文件编码必须为 UTF-8，这一点请用户注意。每篇 Blog 都有固定的参数必须填写，参数如下，注意每个参数的 : 后都有一个空格： title: title date: yyyy-mm-dd categories: category tags: tag #多标签请这样写： #tags: [tag1,tag2,tag3] #或者这样写： #tags: #- tag1 #- tag2 #- tag3 --- 正文]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小谈Android系统文件目录]]></title>
    <url>%2F2017%2F01%2F11%2F%E5%B0%8F%E8%B0%88Android%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[从高三第一次用安卓手机开始，笔者便走上了刷机的不归路。其实今天谈的东西呢，主要是一些基础知识，也就是笔者刷机阶段所学到的一些东西。Android基于Linux系统开发，大多数系统目录和Linux也差不多，但是还是有些不一样的。从一个其他系统包移植到官方包，我们最开始操作的是两个文件，也就是第三方包和官方包的system.img和boot.img，从名字可知，system是系统，boot就是内核还有一些底层的东西。 解包system使用cygwin解包system，得到的就是下面的目录：其中META-INF是脚本，系统在更新（刷机）时候执行的就是这里面的脚本文件，当然打包前后的语法是不同的。system文件夹自然是解包的system文件，具体结构如下：下面再来一张Android手机root之后的系统文件目录：可以看到这两个目录基本一模一样。其中的app和priv-app存放的都是系统程序的apk文件，同理如果要把一个软件安装成系统文件，直接扔到这个目录下重启就行了（不同版本不同）。bin存放的是常用的系统本地命令（二进制），大部分是toolbox的链接（类似于嵌入式Linux中的busybox）。etc存放系统配置文件，如hosts。framework，Java平台架构核心库，jar包和odex优化的文件，我更愿意叫它框架，Android2.3的状态栏图标就是要在这个文件夹下的framework-res.apk文件中修改。font，字体。lib，系统底层共享库，.so库文件。media，系统音频文件（比如照相机声音）以及开机动画。xbin，不常用的系统管理工具，相当于linux的/sbin。usr，存放用户配置文件。 data目录对于Android开发人员来说，使用最多的当然是data目录。data存放的是数据，系统软件、个人软件的数据都存放在这里。较为重要的目录是app和data。 data/appdata/app同system/app一样，只不过存放的是个人软件的apk安装包（注：高版本的Android系统下data/app目录里面按照软件建立了很多文件加，里面便是对应apk文件）。 data/datadata/data存放的是数据信息，里面按照包名建立了很多文件夹，分别是对应软件的数据目录，数据库，文件，缓存，配置文件之类的。Android文件操作的Context.getFilesDir()，Context.openFileOutput()获取的目录便是data/data/&lt;包名&gt;/files目录，此外还有cache目录（Context.getCacheDir()），shared_pref目录（Context.getSharedPreferences() 建立的preferences文件（xml）存放目录）。 sd卡下Android目录在sd卡的根目录下也有一个Android文件夹，这也是比较重要的。也许你偶尔会发现自己缓存的视频就存放在这个文件下。里面分为data和obb文件夹，data是运行时产生的数据存放位置，obb一般是数据包（比如大型游戏的数据包）存放位置。data下又是按照包名区分的，里面也有files和cache文件夹，同data/data，但是代码访问时是通过Context.getExternalFilesDir()和Context.getExternalCacheDir()访问的。这些知识呢算是基础，应该自己去学习的，搞Android开发的偶尔玩玩手机也是不错的，不然写一个数据库结果连存放在哪里都不知道。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Rom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio与github的使用（多人开发源码同步问题）]]></title>
    <url>%2F2017%2F01%2F11%2FAndroid%20studio%E4%B8%8Egithub%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91%E6%BA%90%E7%A0%81%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[之前和朋友一起写一个Android APP，代码不算难，只是要我们一起写，这就出了一些代码合并上以及同步的问题。今天讲的主要是GitHub上分支保持与主干源码同步的问题。 之前使用的时候就是项目挂在笔者的GitHub上，别人修改的代码提交一个pull request就能够合并到主分支中，但是一直没解决的问题是主分支代码更新了，但是别人的fork的仓库却并没有更新，这个问题课难倒了我们，弄了几次都没成功，后来就一直删除仓库，重新fork来保证代码的更新。 现在，这个问题终于解决了。我来简单写一下解决步骤： 1.下载git客户端相信如果要用Android studio的提交，应该都下载了git并且配置完毕。 2.启动命令行打开项目文件夹根目录，右键git bash here，打开git命令行。 3.查看仓库地址输入 git remote -v 查看项目的仓库地址，一般来说都是如下图的样子： 4.添加远程仓库输入以下指令添加远程仓库： git remote add upstream https://github.com/test/xxxxx.git 其中upstream是远程仓库的名称(可更改),后面跟的是远程仓库的http地址,如下图: 5.检测更新完成上面的步骤之后你就可以开始和朋友进行开发了,你fork了他的源码,当他更新的时候,你只需要在这个文件夹里打开git命令行,输入 git fetch upstream 它会检测远程仓库的所有分支的更新情况 6.切换到主分支git checkout master 继续执行以下代码: git merge upstream/master 这样你就把他更新的代码合并到本地了. 7.更新这个时候进入Android studio你会发现文件更新了,然后执行push,就能把新的代码提交到你的仓库中了.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
</search>
